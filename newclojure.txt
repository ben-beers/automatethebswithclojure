If you're reading this, it's because you're relatively new to programming and have decided, either by assignment or volition, to begin with Clojure. This text serves n purposes:

1. To teach you to program. Teaching you to program, period, is a higher priority than teaching you to program in Clojure. Clojure is good, Clojure has a great deal of potential, Clojure is a great language to begin wtih, Clojure is easy to use, and Clojure is versatile, but programming is a skill unto itself, quite apart from programming in any particular language. It's similar to how a painter can paint; a painter may use oils or he may use watercolors, and may be more skilled with oils or more skilled with watercolors. Fundamentally, though, a painter is a painter, and a good painter could easily pick up watercolors or oils if he so desired. Programming is similar. You can program in Clojure, Python, Ruby, Java, or C++, but a good software engineer knows how to THINK like a programmer, and this enables him to quickly pick up any language. This book uses Clojure, much as an introductory painting class may begin with watercolors, but fundamentally it's about teaching you to program, much as the introductory class is about teaching you to paint.

2. To teach you to program IN CLOJURE. As said before, this is not the highest priorit, but it is certainly one of our priorities. Clojure is a versatile functional programming language (and we will discuss programming paradigms later) and it runs on the Java Virtual Machine (which we will also learn about later). That means that you can use it for lots of different things, it will become extremely popular soon, and it runs on almost any computer. All of those things make Clojure a good language to learn.

3. To teach you to automate the bullshit with Clojure. Let's face it: there is a lot, and I mean a LOT, of drudgery and menial work and data entry and all-around bullshit that is required for anyone with an office job. With Clojure, you can write scripts to shovel the bullshit while you do more important things. Learning to program and automate the boring bullshit will be one of the best decisions you ever made.

So now that we know what we want to do, let's set about laying out how we're actually gonna do it!

Remember that everything in computer programming is about starting with itty-bitty pieces and building them up into bigger things like a brick wall. If you understand how gears work, then you can make them mesh and turn one another. If you understand axels as well, then you can put the gears onto axles and build a gear assembly. And if you understand both of those things plus weights and levers, you can combine it all to make a clock. We begin with the tinest of tiny pieces, and slowly, step-by-step, we build up until we know how to make software that can do stuff for us. Accordingly, we begin with what is known as "flow control", or the basic, fundamental logic of what makes programs work. We then use flow control to combine logical statements into functions, which are little logical structures that we can use over and over again. Then we combine the functions into fully-fledged programs.

It will feel a little tedious at first, as it often does when one is learning the rudiments of a discipline. If you do martial arts, you might begin by doing drills, which can be very boring to beging with. If you take piano lessons, you might begin by playing up and down scales, which is extraordinarily boring and feels a little pointless. When you were taught mathematics as a child, they probably made you do a lot of boring stuff involving flash cards and times tables and repetition, which you probably hated because of how boring it was. Learning flow control will feel tedious like this, because flow control is the basic, fundamental ABC of programming. Once you've mastered it, however - and that will happen quite a bit sooner than you think - you will then be able to write functions, and things will accelerate quickly from there.

Of course, before we can do any of this, we'll have to download and install Clojure and run it. We'll execute our first few commands through something called a REPL, also known as an interactive shell. Installing Clojure requires that you have a terminal program to use, i.e. a command line interface. Command line interfaces are standard in Linux, but this book will assume that you're running Windows rather than Linux because of how common Windows is. Now, Windows does come with its own CLI (command line interface) known as Command Prompt, but Command Prompt is not suitable for the kind of work that we'll be doing. So install a better terminal program. If you're enrolled in a course that uses Git, then Git Bash is a good CLI because it comes with some color coding and other cool Git-related features. We'll be usig Git to install closure anyway, and a good developer knows how to use Git, so install Git Bash.

Once Git Bash is installed, you can use it to install Clojure. This is not a Git instructional, so I will tell you what to do without saying why you ought to do it. Git is an entire field of its own and you need only type a few commands to get started with Clojure. First, we install Git. This is easily accomplished by visiting git-scm.com and downloading the appropriate .exe file, then running it. Once Git and Git Bash have both been installed, we can proceed to install Clojure. This is accomplished 
