CHAPTER ONE

To begin with, you'll want to install Clojure. Clojure runs on the JVM, which means we'll be installing Java first. What dependencies Clojure has will depend heavily on what OS you're running. The rest of this chapter will assume that you're running Linux. In particular, we're assuming that you're running some flavor of Ubuntu. A Debian-based or other distro may have slightly different requirements. On a Windows install, you will want to set up a Linux virtual machine to install Clojure on. If you just want to experiment with the REPL without actually writing full-length programs, repl.it has an in-browser Clojure REPL that you can use.
The dependencies for Clojure in this context are bash, curl, rlwrap, and Java itself. the sudo apt-get install command should suffice to install most of these on most Linux distributions. If that doesn't work, try running sudo apt-get update first, and then installing. Any further troubleshooting will depend on what version/distro of Linux you are working with.
Once everything has been installed, you can begin playing with Clojure by typing clj into your terminal. This initiates a REPL for closure. REPL stands for Read, Evaluate, Print, Loop. This is a very fancy way of saying that we have initiated an interactive shell for Clojure. What that means is that we can type in stuff from the Clojure language and see output in real time. We can type in functions, literals, commands, and so on, and watch the interpreter do stuff in real time. It is very similar to Python's interactive shell. The "read" part of REPL is where the interpreter reads our input that we type in at the command line. The Evaluate part of REPL is where the interpreter evaluates that input to produce output for us. The Print part of REPL is where the interpret takes the output and displays it on the command line. REPL: Read, Evaluate, Print, Loop.
Once we have the REPL open, we can mess with Clojure a little in order to see what various commands do and how the interpreter responds to different stuff from the Clojure language. You can begin by typing in some literals, such as 42, 42.0, "String", and so on. You will notice that literals evaluate to themselves, i.e the interpreter prints out whatever literal it was given as input.

The REPL will be our tool early on because it allows us to type in commands and try different things. You will remember these things much better if you actually do them instead of just reading about them. Much as a pianist will remember a scale much better if they sit down and actually play that scale, a software developer who employs the concepts that they are learning will retain those concepts much better than if they merely read about them.

To begin with, we'll start with the arithmetic operations, since these are the easiest and most basic operations. Open up your REPL and type this:

(+ 1 1)

And press enter. If you do so, the program will return,

=> 2.

What happened? Right of the bat, this looks a little different from the math you saw in school. Ordinarily, in your school mathemetics, the plus sign, as well as other OPERATORS such as the division and multiplication signs, went between numbers. But here, those operators go at the beginning, and the whole thing is enclosed in parentheses. What's going on here!?

To begin with, everything in Clojure is a function. Whenever you enclose something in between those two parentheses, you're not just categorizing it the way you do in algebra. Rather, every set of parentheses CALLS a function. That means that those parentheses say to Clojure, "Hey, you! See these parentheses? There's a function inside of here, which is a set of instructions for you to follow. Look inside of these parentheses and execute this function!" Every set of parentheses in Clojure is a function call. Functions in Clojure, as stated, are a set of operations or instructions, and zero or more ARGUMENTS. Think of the instructions and operations as a machine, and think of the arguments as a set of things that you put into one end of that machine. What comes out the other end of the machine is the result of applying those instructions to that argument. So when you type (+ 1 1), you're taking the plus + operation and feeding it two integers, 1 and 1, and having it add those together. The integers are the arguments to the function, and the function itself, in this case, consists of adding the arguments together.

Another difference between the operations you learned in school and the operations in Clojure, besides just the order you write them in, is how many arguments they can take. In school, you wrote addition like this: 1 + 1, and the result like this: = 2.The addition you learned in school is a "binary operation" or an operation that operates on two things, in this case the numbers on the left and right. Clojure addition, however, is not limited in this way. In Clojure, addition can operate on as many things as you want! So you can try typing the following into your REPL:

(+ 2 3)
(+ 3 5 7)
(+ 7 5 3)
(+ 7 11 13 17 19 23)
(+ 31)
(+)

And notice what happens. No matter how many arguments you put in, the addition operator will faithfully gather them all up and add them all together. And this works for all of the arithmetic operators, which are as follows:

+
-
/

These are addition, subtraction, and multiplication. There is no exponentiation symbol in Clojure, although there are, of course, ways to crete an exponentiation function, which we shall learn about later. To see how subtraction pans out, try the following:

(- 10 5)
(- 5 10)
(- 1 2)
(- 2 1)
(- 2 3 5 7 11)
(- 23 19 17)

Finally, we come to our third basic operator in Clojure, which works a little differently than you might think: division. Division in Clojure can be done differently depending on the kind of number you're dealing with. And this, incidentally, is a good place to introduce the two most basic types of numbers in Clojure: ints and doubles. Ints are integers, meaning simple numbers with nothing after the decimal point. Doubles are decimal numbers. Try typing the following:

(type 1)
(type 2)
(type 3)
(type 1.0)
(type 2.0)
(type 3.0)

The type function tells you what type of thing a thing is. The type function only takes one argument.

Now, the reason we've taken this little detour to talk about data types is this: how division works changes based on what kind of number you use. Using division on integers is very different from using division on doubles. Try the following in your REPL:

(/ 2 3)
(/ 4 6)
(/ 8 12)
(/ 6 2)
(/ 6 3)
(/ 2.0 3)
(/ 2 3.0)
(/ 4.0 6)
(/ 6.0 3)

You'll notice something interesting: what result you get back from the division depends on what kind of number you give it. If you give the division operator at least one double, you'll get back a double. So (/ 3.0 2) and (/ 3 2.0) both give you back 1.5. However, if you only give integers to the division operator, you'll get something else back. You'll either get an integer, if the denominator divides evenly into the numerator, or you get what is known as a ratio. The ratio is basically a fraction. It automatically reduces to its simplest form. Since 4/6 reduces to 2/3, running (/ 4 6) will yield the ratio 2/3.

Obviously, if all you could ever do was just feed a few arguments into a function, you would never get much done in Clojure. That's why functions can be composed, or put together, to make new things. Try the following in your REPL:

(* (/ 3 2) 2)
(/ (+ 5 7) 6)
(+ (/ 1 3) (/ 1 3) (/ 1 3))
(- 1 (/ 1 2))

Similarly to the algebra used in school, the inner parentheses are evaluated first, and then the results of those expressions are evaluated within the larger parentheses. Composing functions in this way is the brass tacks of how we build big things in Clojure.

There's one last data type you need to know about, and that is the string. A string is a sequence of characters. When we're scraping websites later on, string manipulation will be important, because a lot of the data that we download from websites will be in text form, which means it will be stored in strings. Try the following in your REPL:

"put"
(str "put " "it")
(str "put " "it " "all " "together!")
(str "with numbers, too, such as " 1 "!")

You'll notice that entering a string into the REPL returns a string, while using the str function sucks up any argument you put in there and then returns one big string of everything you fed the function.

Finally, variables. Think of a variable as an envelope, and of the value of that variable as the contents of the envelope. Variables store values. An envelope can hold a five dollar bill, or a ten dollar bill, but it is not, itself, a dollar bill. It can also change, where you take out the five dollar bill and put in a ten, or vice versa. You can even leave it empty! Variables are much more important in other programming languages, such as Java and Python, because many popular languages are "object oriented." This means that other languages have this notion of a 'stateful' object, or an object with states that can change. For example, in other languages, you might have a class that has a lot of different attributes that can all change. In Clojure, there is only one type of variable that you should use, and that is the atom. We define an atom using the def keyword, thus:

(def five-dollar-bill (atom 5))

Type those two, and then try the following in your REPL:

five-dollar-bill

@five-dollar-bill

(+ five-dollar-bill five-dollar-bill)

(+ @five-dollar-bill 5)

Notice what you get in each case? five-dollar-bill, by itself, refers to the container, the variable, while @five-dollar-bill refers to the variable, the thing inside of the envelope. Let's make another one. Try the following commands, one at a time.

(def dollar-bill (atom 1))

@dollar-bill

(swap! dollar-bill + 10)

The swap! function changes what's in the envelope for something else. In this case, it lets you add ten to whatever's in the envelope, which is like putting more money in there. You can also take money out:

(swap! dollar-bill - 10)

We can also define atoms as strings and add to those strings. Try the following, one at a time:

(def name (atom "Sir"))

(swap! name str " Arthur")

(swap! name str " Conan")

(swap! name str " Doyle")

@name

(reset! name "Edgar Alan Poe")

@name

(reset! name 1003401)

@name

It's always a good idea to use descriptive names in programming. You'll notice that the five-dollar-bill atom contained the value 5, while the dollar-bill atom, which changed values a lot, had a more general name. Meanwhile the variable containing strings containing the names of various famous authors was called "name" to reflect that. This is part of "style" or the conventions that software developers use to make sure their code is readable for other software developers.

Now that we've learned the nuts and bolts of Clojure, let's create our first Clojure program! To begin with, type "vim helloworld.clj" into your terminal. This will open a buffer. Press I to enter insert mode, and type the following:

;This program will say hello and then ask for your name
(println "Hello, world!")
(println "What's your name?")
(let [username (read-line)]
(println (str "Pleased to meet you, " username "!")))

Press the esc key, type :wq and then enter. :wq stands for "write quit," which will save (write) your file and then quit the program. Now that you're back to your normal terminal, try this:

clj helloworld.clj

And watch the magic! The program will print "Hello, world!" and ask for your name. Type your name, and it will greet you by name. Et voila! The program executes top to bottom and then returns to terminal when it's done.

Let's dissect this program and see what's going on under the hood.

First of all, we have this line:

;This program will say hello and then ask for your name

This is a COMMENT, which is just a note to anyone reading your source code telling them what the source code does. Then we have the following:

(println "Hello, world!")
(println "What's your name?")

This is the println function, which prints a line of text to the terminal and then enters a line break, so that whatever prints next is on a new line. The println function, in this case, takes a string as an argument and prints it out. The line break is there to make sure that whatever prints next doesn't print on the same line, which is why "Hello, world!" and "What's your name?" print on two separate lines. Next up is:

(let [username (read-line)]
(println (str "Pleased to meet you, " username "!")))

The 'let' keyword defines what is known as a symbol. This isn't one hundred percent accurate, but for right now, it's okay to think of a symbol as a variable that never changes. In reality, there is a more subtle difference than that, but for now, it's okay to think of it as an immutable variable, even if that's not QUITE what it is. The let keywork here works like this:

(let [symbol (thing)]

which means that we're saying, "Let this symbol stand for this thing." In this case, the thing in question is the read-line function, which tells the program to pause and wait for the user to type something and press enter. So whatever the user types, is what the username symbol stands for. Finally, we have

(println (str "Pleased to meet you, " username "!")))

You will remember that the str function takes all the stuff you give it and sticks it into one long string. But the word, username, is not in quotes. If it were inside of quotes then the println function would print out, "Pleased to meet you, username!" because it would think that username was just the insite of the string. But it's not, so it gets EVALUATED and the program looks past the symbol and grabs whatever the symbol stands for. So if the user types in "Bob" for their name, the program will say "Pleased to meet you, Bob!" instead of "Pleased to meet you, username!" because it understands that username is just a symbol for whatever the user typed in and not a literal string.

Before we wrap up this chapter, we have a few more functions to learn. The first one is count. You can use it to find the length of a string. Try this in your REPL:

(count "Artichoke")

And it will give you

=> 9

Now try these in your REPL, one at a time:

(count "")
(count "Psych! I'm actually a star-spider.")
(count "Eenie Meenie Miney Moe")

And see what you get back.

Finally, let's learn about casting, or, as it's known in Clojure, coercing. Coercing is a way of turning one data type into another. Try the following in your REPL, one at a time:

(type 9)
(str 9)
(type (str 9))
(type "9")
(int "9")
(type (Integer/parseInt "9"))

Notice how that works? The str function can take the long 9 and turn it into a string, and the type keyword tells you what's going on there. The type of 9 is long, but the type of (str 9) is a string. The type of "9" is a string, and (str 9) returns "9" and is thus equivalent to it. Ditto for (Integer/parseInt "9"). This is called coercing, and it will become important later when we have big text files and we're hunting through them for numerical data to feed into our functions. On the other hand, if we want to put a number into a string and write that into a text file, coercing the number into a string may turn out to be useful.

Now, let's finish up by adding a few more lines to our program:

;This program will say hello and then ask for your name
(println "Hello, world!")
(println "What's your name?")
(let [username (read-line)]
(println (str "Pleased to meet you, " username "!"))
(println (str "Your name is " (count username) " letters long.")))
(println "How many years old are you? Type a number.")
(let [userage (read-line)]
(println (str "You are " userage " years old, and you will be " (+ (Integer/parseInt userage) 1) " in a year.")))

Notice how the last few lines do not do anything new, but uses what we've already learned to expand on the original concept a little. Now it tells the user how old they are, and how old they will be in one year. Note how Integer/parseInt is used to coerce the string into becoming an integer so we can add 1 to it, and also notice how the str function near the beginning of the final line turns it all back into one big string.

SUMMARY
So far, we've learned how to do basic arithmetic in Clojure, how to cast different data types as one another, what are data types exactly, how to get user input, what are variables and atoms, and how to use a REPL. In the next chapter, we'll go a step further and learn flow control. Flow control will take much of what we're doing and put it together into a larger structure.

CHAPTER TWO - FLOW CONTROL

The program we wrote last chapter executed from beginning to end, top to bottom, like a grocery list, just going down the page and executing the instructions one at a time. Very few real-life programs work like this, though. In real programs, the computer makes decisions: it can execute a single instruction multiple times, skip some instructions, or choose which instructions to run. The means of doing this is called flow control, and it works in a manner very similar to a flowchart. Observe this diagram (see: flowchart.png).

This is an instance of flow control using what are known as if-else statements. First, we start with a situation where the computer does not work. IF it is not plugged in, THEN we plug it in. ELSE, we go to the next step and ask if the computer is turned on. IF it is turned on THEN we restart it. ELSE, we turn it on. This is an instance of flow control. In order to make a computer program that works like a flowchart, you need to have a way to represent truth and falsity, yes and no; "Is the computer turned on?" is answered with yes or no because it is either true or false that the computer is turned on. In this case, we are using what is known as boolean values.

A boolean operation turns on whether or not a value is true or false. Fire up your REPL and try the following:

(= 1 1)
(= 1 2)
(true? (= 1 1))
(true? (= 1 2))
(false? (= 1 1))
(false? (= 1 2))

You'll notice that (= 1 1) returns true and (= 1 2) returns false because 1 does not equal 2. (true? <statement>) returns true if <statement> is true, and (false? <statement>) returns true if <statement> is false. Clojure can return boolean values in many other ways as well, using these comparison operators:

=	|equals
not=	|does not equal
<	|less than
>	|greater than
<=	|less than or equal to
>=	|greater than or equal to

These are comparison operators that return boolean values when they compare two things. Try the following commands in your REPL, one at a time:

(not= 1 1)
(not= 1 2)
(< 2 3)
(< 5 3)
(> 5 7)
(> 7 5)
(<= 7 11)
(<= 11 7)
(<= 11 11)
(>= 7 11)
(>= 11 7)
(>= 13 13)
(= 17 17)
(= 17 19)
(= 19 17)

This should give you a good gut feeling for how these comparison operators work, but we're not quite done yet. You might have guessed by now that these comparison operators work differently depending on what data types you give them. A string is never equal to a number, for example. To verify this, try the following in your REPL, one at a time:

(= 0 "0")
(= "0" "0")
(= "0" "Clojure")
(= "Clojure" "Clojure")
(= "Clojure" "clojure")
(= 0.0 0.0)
(= 0 0.0)

However, even though different data types are never equal, some operators can, in fact, take operands of different types (an operand is just the thing an operator takes, e.g. a and b are the operands for a + b and the operator is +). For example inequality operators can take operands of multiple types. Try these in your REPL:

(<= 2 2.0)
(< 2 99.321)
(> 2 500)
(> 2.1 0)

In addition to comparison operators, there are also boolean operators, or operators that return a boolean value and take boolean values. The three boolean operators are AND, OR, and NOT. Try the following in your REPL:

(and true true)
(and false false)
(and true false)
(or true true)
(or true false)
(or false false)
(not true)
(not false)

Notice that both AND and OR take two operands, while NOT takes only one. Also notice that NOT returns true when you give it something false, and false when you give it something true. It can be helpful to think of NOT as something that just flips whatever value you get it. And yes, flipping something twice does return it to its first state. Try these in your REPL:

(not true)
(not (not true))
(not false)
(not (not false))
(not (not (not (not (not true)))))

A handy thing to remember: an even number of NOTs returns the original truth value (a truth value is just whether or not something is true or false) while an odd number of NOTs returns the opposite of the original truth value.

To keep all this stuff straight, it helps to use what is called a truth table. A truth table is a table that tells you when an expression is true or false, based on the truth or falsehood of the things inside of that expression. Here are the truth tables for AND, OR, and NOT:

a	|b	|(and a b)
T	|T	|T
T	|F	|F
F	|T	|F
F	|F	|F

To read this table, look at the truth values for the a and b first, and then for the expression (and a b). Notice that (and a b) is true only when both and b are true. Or is a little different:

a	|b	|(or a b)
T	|T	|T
T	|F	|T
F	|T	|T
F	|F	|F

Notice that (or a b) is true when a is true, when b is true, and also when both are true. That last part is something you need to take notice of: the or operator is what we call an "inclusive or", meaning it's true when both of its operands are true. There is an old joke about the inclusive or that runs like this: a logician has a child. Someone asks the logician whether the child is a boy or a girl. The logician replies, "Yes." Later on, the logician drinks a little wine, and then a little beer. Someone asks the logician, "Did you have wine or beer today?" and the logician again replies, "Yes."

Finally, the truth table for not, which is quite simple:

a	|(not a)
1	|0
0	|1

As you can see, whatever you input for a gets flipped around to the other value.

You can mix boolean and comparison operators because comparison operators return boolean values and boolean operators take boolean values (and return them). Try this in your REPL, but be careful to get it exactly right:

(not (or (and (= 1 0) (>= 11 7)) (not= 5 5)))

You'll notice that this returns true. The reason is that the comparison operators in the inmost parentheses are evaluated first:

(not (or (and (= 1 0) (>= 11 7)) (not= 5 5)))		|The original expression
(not (or (and false (>= 11 7)) (not= 5 5)))		|(= 1 0) is falsHA
(not (or (and false true) (not= 5 5)))			|(>= 11 7) is true
(not (or (and false true) false))			|(not= 5 5) is false
(not (or false false))					|(and false true) is false
(not false)						|(or false false) is false
true							|(not false) is true

Now that we've learned a bit about boolean operators, comparison operators, and boolean values, we can proceed to flow control, as promised.

The most basic flow control statement is the if statement, as we noted before. The if statement has the structure, (if <condition> <clause> <else>). If <condition> has the boolean value of true, then <clause> is executed. If not, then <else> is executed. Try the following in your REPL:

(if true (+ 1 1))
(if true (+ 1 1) (+ 1 2))
(if false (+ 1 1) (+ 1 2))

Notice that you don't need an else clause. You just say, "If this, then do this." But, Clojure is flexible enough to let you say, "If this, then do this, but otherwise to this," which is what the <else> clause is about. You can also add other expressions into the if statement. Try this in your REPL:

(def number (atom 5))
(if (= @number 5) (print "Five!") (print "Some other number."))
(swap! atom + 1)
(if (= @number 5) (print "Five!") (print "Some other number."))

In most terminals, pressing the up arrow on your keyboard will allow you to re-enter a previous line. But notice what happens! If you run the test when number holds the value of 5, then the clause is executed, because (= @number 5) evaluates to true. Notice how the flowchart logic works here: (see atomflowchart.png). The condition part of the tree can be anything so long as it finally becomes a boolean value when the program is done evaluating it, and the clauses can be whatever you want as long as it's a set of instructions Clojure can understand.

Another important flow control operator is WHILE. The WHILE operator takes a condition, much like the IF operator. The difference is that the IF operator will only execute once. The WHILE operator, by contrast, will execute over and over until its condition is no longer true. For example, try this in your REPL:

(def a (atom 0))
(while (< @a 10) (do (println @a) (swap! a inc)))

Notice the structure of the while statement: (while <condition> (do (this) (this) (and this))). While <condition> is true, everything in front of the do statement will be executed over and over until the condition is no longer true. In this case, it prints the value of a, and then adds 1 to a, and the condition is that it will do this until a is no longer less than 9. Now, try this in your REPL:

(def a (atom 0))
(while (< @a 10) (do (swap! a inc) (println @a)))

Notice that the output you get for this is a little different now. Can you figure out why?

SUMMARY: in this chapter, we learned about flow control, boolean statements, and boolean values. In the next chapter, we will put together our flow control and boolean values in order to create functions, which will enable us to write real programs.

CHAPTER 3 - FUNCTIONS

A function is like a miniature program-inside-a-program. The point of a function, fundamentally, is to create a block of code that you can execute at will by CALLING it. Think of a function as a little machine that does a task over and over. Try writing this in your REPL:

(defn my-function [] (+ 1 1))

You have now defined a new function called my-function. Now try this:

(my-function)

Every time you type this, the REPL will print 2. So, what's going on here? Well, the defn keyword stands for "DEfine FuNction" and is there to let Clojure know that you want to make a new function. So the structure of the statement is like this:

(defn <name-of-function> [<parameters>] <code>)

As you can probably tell, name-of-function is whatever the function is going to be named. By typing that name in parentheses, you can call that function. <parameters> are sort of like slots in the function for the arguments you want to pass to it, and <code> is whatever you want the function to do with those parameters. For example, try this in your REPL:

(defn add-and-double [a b] (* 2 (+ a b)))

(add-and-double 19 17)

That second line will return:

=>72

Clojure will add a and b together when it evaluates the innermost pair of parentheses, which it will do first. It will then multiply their sum by 2, and return the result. Putting [a b] into brackets like that tells Clojure that this function will take two arguments, and the arguments will be referred to by the parameters a and b. That means that, when you call the function, you replace the parameters a and b with whatever arguments you want to feed into the function. Take a moment to reflect on the power of that! You can create a block of code - any code you want - and tell it what arguments to take, and what to do with those arguments. We DEFINE a function by labeling it with a name and telling Clojure what it does, and give it PARAMETERS so it knows how many ARGUMENTS to take. We can then PASS arguments to the function according to its defined parameters. The difference between an argument and a parameter is a subtle one, so I'll take a minute to explain it further: a parameter is part of a function, while an argument is something you put into the function. In our function above, a and b are the parameters, or the part of the function definition that tells it how many arguments to take. The arguments are 19 and 17, which are the things we put into the parameters.

Another distinction that is somewhat subtle is the difference between a VARIABLE, a KEYWORD, and a SYMBOL. A variable is like an envelope containing an object, and the object in the envelope can be swapped out or modified. In Clojure, only atoms are variables. A symbol is one thing that stands for another thing: when we write "def n 7" we are defining n as 7. It's important to note that this is NOT a variable, although the syntax with which we declare it is similar to how other languages declare variables. Rather, n is a SYMBOL for 7, and is considered immutable, like all data types in Clojure besides atoms. Once we declare n to be 7, it is 7 for as long as it exists.

When functions are executed, the program is essentially stopping and going to some other line of code, executing that block of code, and then returning to where it was. So if we write:

1. (defn add-five [x] (+ x 5))
2. (def k 3)
3. (print "Let's take a look at this function: ")
4. (add-five k)

and execute it, Clojure reads the whole program top to bottom. When Clojure reaches line 4, it stops and returns to line 1, and executes whatever code it sees there, replacing x with whatever argument was passed in line 4. In this case, we passed the symbol k, which is evaluated to 5, and then passed as an argument to the function defined on line 1. You can think of functions, in a sense, as an instruction for the program to stop and backtrack to where it was previously, and execute whatever code is defined under the name of that function.

This brings us to another critical discussion that we need to have in order to really understand Clojure, which is the discussion of scope. Scope is a concept that you'll run across in pretty much any modern programming language, although different languages have different ways of dealing with it. Scope basically tells you where a name is valid. Consider the following bit of code, which you can write into a .clj file and run to see its output:

1	(def z 2)			|Create the symbol z and associate it with 2.
2	(defn add-3-to-z [] (+ z 3))	|Create a function that returns z + 3, so 5
3					|
4	(let [z 5]			|Let z equal 5.
5	(print (+ z 3)			|Print z + 5
6	(add-3-to-z)))			|Call add-3-to-z

You'll notice something a bit strange: line 5 prints out 8, while line 6 prints out 5. So the z in line 5 is equal to 5, while the function call in line 6 references the z defined on line 1. In fact, the z defined on line 1, and the z defined on line 6, are two different symbols! What's going on here? How come the definition on line 4 doesn't overwrite the definition on line 1? Shouldn't the value of z change after line 4? And how come line 6 still knows what the definition of z on line 1 was? How in the world does all this work!?

The answer is scope. The z defined on line 1 is a GLOBAL symbol, meaning it's valid everywhere in the program, unless it is SHADOWED by something else. In the case of line 4, z is temporarily shadowed when we write let [z 5].Inside of those parentheses where let occurs, z = 5. When we call the function on line 6, however, the program backtracks to line 2. THAT z refers to the definition in line 1, because the function is defined outside of the let block.

It's okay to be confused by that last paragraph. Scope can be a little hard to understand. Another way to think about it is this: think of a let block as a room. Inside of that room, z is defined as 5, so whenever you say "z" inside of the let room, it means five. But after you step outside of that room, z stops meaning five and goes back to meaning 2. The function is sort of like a little machine: when you call the function, it leaves the room, finds a z that means 2, and then comes back into the room and returns the result.

Finally, it's time to talk about EXCEPTION HANDLING. One of the realities of software engineering is that things go wrong; programs have bugs, developers make mistakes, users input things they should not, programs crash, hardware doesn't always work the way it's supposed to, and so on. Exception handling is one way that we can deal with this as developers. Exception handling is a neat feature of many programming languages that allows us to build contingency plans into the program itself. The idea is that, instead of just straight-up executing a piece of code, we can instead TRY to execute a piece of code and, if that results in an error, default to something else. Here's an example of how we can use exception handling in Clojure. First, type this in your REPL:

(defn divide-3-by [x] (/ 3 x))

Once you've defined that function and then pressed enter, go ahead and try the following:

(divide-3-by 5)
(divide-3-by 2)
(divide-3-by 0)

You'll notice that that last one throws an error, because you're performing a mathematical operation that is undefined. The question now arises, how can we anticipate this from the user? We, of course, as impeccably wise and learned software developers, know well enough that you cannot divide by zero. But what if someone, a user of our program, makes an input to this function that doesn't work? How can we get around that? The answer is exception handling. Type into your terminal vim exceptions.clj, and write the following code:

(defn john-wayne-division [x]
  (try
    (/ 3 x)
    (catch Exception e "Looks like you tried some division you ain't supposed to, partner!")))

(john-wayne-division 3)
(john-wayne-division 1)
(john-wayne-division 0)
(john-wayne-division 7)
(john-wayne-division "Wild west division!")
(john-wayne-division nil)

Hit escape, then type :wq and press enter to write to the file and quit vim. Now, in your shell, type clj exceptions.clj and press enter. You'll notice that, whenever you try to divide by 0, or do something even more goofy like trying to divide by a string or the nil value, the exception handling activates and John Wayne advises you not to try that again. As fun as that example was, it also helps to try something a little more normal:

(defn normal-division [x]
  (try
      (/ 3 x)
          (catch Exception e (str "got exception: " (.getMessage e)))))

This example showcases why we give the exception a name in the first place. The exception is named e, which means that it's a symbol representing the exception created when we do something stupid like dividing by 0. In this case, Clojure will print out a message from the exception telling us what went wrong, such as trying to cast a string to a number or attempting to divide by zero.

##WILL NEED COLLATZ EXERCISE HERE

CHAPTER 4 - LISTS, VECTORS, AND THEIR METHODS

Most modern programming languages implement some variety of COLLECTION, meaning a data structure that can hold a list or collection of things. For example, Java has lists, maps, and arraylists; C++ has arrays; Python has lists and dictionaries. Clojure implements java.util.collections, meaning it is built on the library of collections available to the JVM. In layman's terms, anything you can do with collections in Java can also be done in Clojure.

The most commonly-used collection type in Clojure is the VECTOR. When you see lots of values inside of a set of brackets, like this: [1 2 3 4 5], you know that you're dealing with a vector. Clojure also uses LISTS, but lists in Clojure are generally used when you want to process something from back to front. Generally speaking, it's advisable to use vectors instead. The reason that you use lists to process things back to front is that lists expand by being PREPENDED, while vectors expand by being APPENDED. To prepend means to add to the beginning, while to append means to add from the end. To see how this works, run the following two commands in your REPL, one at a time:

(conj (list 2 3 5) 7)

(conj [2 3 5] 7)

You will notice that, for the first command, the 7 is added to the beginning, while for the second command, the 7 is added at the end. In the first case, the 7 is PREPENDED, meaning it has been added to the beginning of the list. In the second case, the 7 has been APPENDED, meaning it has been added to the end of the list. So for any application where we need to process things back-to-front, or build something backwards, lists can come in handy. Otherwise, vectors are, generally speaking, the better choice.

Before we go any further and learn to really work with vectors and lists, it is important for you to understand the idea of a method. A method, in object-oriented programming, is a function (more broadly, a procedure) bound to a class. Clojure is not object-oriented, but it does have methods in the sense that it has functions defined on classes of things. For example, there are certain methods that only work on certain data structures. In other languages, such as Python, you can have methods that work only on strings, e.g. string.Lower() which changes the whole string to lower case and only works on strings. In Clojure, we call methods the same way we call any other function, but our methods only work if we give them the right kind of argument.

One of the more fundamental methods that works on vectors is the nth method, which we can call thus: (nth <vector> <number>). Try the following in your REPL, one at a time:

(nth [1 2 3 4 5] 0)
(nth [1 2 3 4 5] 1)
(nth [1 2 3 4 5] 2)
(nth [1 2 3 4 5] 3)
(nth [1 2 3 4 5] 4)
(nth [1 2 3 4 5] 5)

You'll notice that the final one gives you an index out of bound exception, which is a fancy way of saying that the vector has no value with index 5. This is because vector (and list) indices count from 0, so 0 yields the first element while 4 will yield the fifth element. It's useful to keep this in mind when we're slicing vectors, which we'll learn about next.

Vectors can be operated upon to return subvectors, or slices of the original vector. For example, try the following in your REPL, one at a time:

(subvec [1 2 3 4 5 6 7] 0)
(subvec [1 2 3 4 5 6 7] 1)
(subvec [1 2 3 4 5 6 7] 2)
(subvec [1 2 3 4 5 6 7] 3)
(subvec [1 2 3 4 5 6 7] 4)

You'll notice that each function has this form: (subvec <vector> <n>), and you'll also notice that each time you call the function, you get back a sub-vector beginning with index n and running through until the end of the list, e.g. (subvec [1 2 3] 1) returns [2 3]. The subvec function can take an additional argument to slice the list instead of just cutting off one end, and when you do so, it has the form: (subvec <vector> <m> <m>). This will return every value in the list, beginning with and including n, and up to but NOT including m. To get a feel for this, try the following in your REPL, one at a time:

(subvec [2 3 5 7 11 13 17 19 23] 0 3)
(subvec [2 3 5 7 11 13 17 19 23] 1 3)
(subvec [2 3 5 7 11 13 17 19 23] 2 3)
(subvec [2 3 5 7 11 13 17 19 23] 5)
(subvec [2 3 5 7 11 13 17 19 23] 3 7)

You can find the length of a vector using the count function, which you call like this: (count <vec>). This returns the number of items in a vector counting at one. Be careful: if you try to make the m in the previous function equal to the number returned by count, then you'll get an out of bounds error because count counts from one whereas subvec counts from zero. Indices count from zero, but the length of the list is given counting from one. Like this:

Index	 0 1 2 3 4 5 6 7
Vector	[A B C D E F G H]
Count	 1 2 3 4 5 6 7 8

So the subvector of this vector that is 4 units long (i.e. [A B C D]) has a count of 4 but its indices run from 0 to 3.

Another important part of working with vectors is knowing how to change their values at different indices. We accomplish this using the assoc method. Try the following in your REPL, one at a time:

(assoc [1 2 3] 0 "A")
(assoc [1 2 3] 0 "A" 1 "B")
(assoc [1 2 3] 0 "A" 1 "B" 2 "C")

Now, try these two:

(assoc [2 3 5 7 11 13] 1 "B" 4 "Z")
(assoc [1 2 3 4 5] 3 [2.5 3 3.5])

Two things.

First, keep in mind that you never change any vector. Right now, when you type these things into the REPL, it may feel as if you're modifying the vectors, as if you're mutating the state of a persistent object. But, that's not true. What's really happening is that you are taking a vector and passing it as an argument to a function that returns a different vector, similar to the one that you just put in. So when you call (assoc [1 2 3] 0 "A") you're passing the [1 2 3] vector to the assoc function as an argument, and the assoc function is giving you back another vector with a single value replaced with a string. This is not just technical pedantry; immutability is a deep part of how Clojure works and keeping this in mind will make other aspects of the language more intuitive when you learn them later on.

Secondly, you'll notice that the assoc function is clever enough to know which value you feed it is an index, and which one is a thing to put into the vector at that index. The structure of the function is: (assoc <vector> <index 1> <thing 1> <index 2> <thing 2> <index 3> <thing 3> ..... <index n> <thing n>). The point here is that you can input any number of indices (up to the number of indices that the vector has) and get back a new vector with those indices holding the things you associated with them using the assoc function. Incidentally, you might have realized at this point why the "assoc" function has that name.

One last note: the "assoc" method can be used to add new values to a vector, so long as the indices you pass to it come directly after the indices of the original vector. It's okay if you find that description confusing, but the description makes it sound more complicated than it really is. It will be easier if we use some examples.

Suppose you have this vector: ["a" "b" "c"]. The three indices here are 0, 1, and 2. Create that vector in you REPL like so:

(def abc ["a" "b" "c"])

And then run this:

(assoc abc 3 "d")

You'll notice that the output for this function is ["a" "b" "c" "d"]. Clojure looked at the vector, saw that there was nothing in index 3, and placed "d" there per your command. Now, if you type abc again, Clojure will return ["a" "b" "c"] without the "d", showing that the original vector has not changed - remember, data structures in Clojure are immutable! - so the assoc function is really just returning a new vector with an extra value. You can add more than one value this way, thus:

(assoc abc 3 "d" 4 "e")

Which will return ["a" "b" "c" "d" "e"], since the original vector had no indices at 3 or 4 and you filled them.

However, you'll get an error if you try this:

(assoc abc 4 "e")

Because there is no index 3, so Clojure is trying to create a vector with some sort of weird gap in it. Clojure can't do anything like that, so you get an error. If you want to use the assoc function to return a new vector with new values that is longer than the original, then the new indices you define values in must be adjacent to the original values.

If you want to check whether a vector contains a particular value, you may do so using the contains method, which you can call thus: (contains? <vector> <thing>). Try the following in your REPL:

(contains? [1 2 3] 1)
(contains? [1 2 3] "A")

When you call contains? it will, unless you feed it something that throws an error, always return a boolean value that simply tells you whether or not the specified thing is in the vector.

There are times when we want to find the index of a particular item within a vector. In these cases, we use the .indexOf method. Try this in your REPL:

(def new-vector ["a" "b" "c" "d" "e"]
(.indexOf new-vector "b")

If all goes well, this will return 1, since "b" is the second value in new-vector. Now, for a slightly trickier example:

(def new-vector ["a" "b" "a" "c"])
(.indexOf new-vector "a")

You'll notice that this command returns 0 rather than 2, even though "a" is present at two indices in new-vector. This is because the .indexOf method only returns the index of the first occurrence of an item in a vector. Therefore, if you have a vector 100 entries long, and that vector has 21 occurences of the string "ABC", and you run (.indexOf that-vector "ABC"), you'll get the index of the first occurrence of "ABC" in that vector.

You can also sort vectors, and other collections too. To sort a vector or list, just type (sort <collection>). As always, the paremeter passed to the function can be the symbol for a thing or the thing itself. Try the following in your REPL.

(sort [0 9 8 7 6])
(sort (list 2 3 1 4 2 5 3 1))
(sort "the quick brown fox jumps over the lazy dog")

You'll notice something funny about that last sort. Well, two things. First, and less importantly, it contains the entire alphabet plus three spaces. Second, and much more importantly, it returns a sequence of letters and the word "space" with a backslash \ before each one. What does that mean? What that means is that you've got a sequence of "characters," which are their own special data type in Clojure. Characters are exactly what they sound like: single letters (or spaces, or quotation marks, or some such) that have their own data type in Clojure. The sort function, when called on a string, contains a sorted collection of all of that string's characters.

You can reverse Clojure collections, too. This is done using, surprisingly enough, the reverse function. Try these in your REPL:

(reverse [1 2 3 4 5])
(reverse (list 2 3 1 4))
(reverse "Bob's your uncle!")

Notice that that last one returns a sequence of characters as well. To get around this and get a true string reversal, we can learn a little about the apply function, and then return ot the reverse function after a moment. Try the following in your REPL:

(apply + [1 2 3 4 5])
(+ 1 2 3 4 5)
(apply str 2 3 5 7)
(str 2 3 5 7)

So far you may be scratching your head. "What gives?" you say, "This apply function just does the same thing as passing multiple arguments to a function anyway." The thing is, apply has this nice property that it can distribute over the contents of a collection, such as a vector or other sequence. To see the power of this, try the following in your REPL:

(reverse "Bob's your uncle!")
(str (reverse "Bob's your uncle!"))
(apply str (reverse "Bob's your uncle!"))

Notice the difference there? That second command returns the whole sequence turned into a string, complete with parentheses and slashes. The third command, however, looks INTO the sequence, plucks out each term, and then applies the str function to those. This brings us full circle, because it gave us a true string reversal, but we also learned something valuable during the journey: the apply command can look INTO sequences, pull out their contents, and apply functions to them. Running the command (str (reverse "Bob's your uncle!")) is like taking an envelope full of jigsaw puzzle pieces, and framing the whole envelope in a picture frame. By contrast, running (apply str (reverse "Bob's your uncle!")) is like taking the puzzle pieces out, and fitting them together inside of the frame. It's obvious which one was more desirable in this case.

There is another function in Clojure called "reduce" that works similarly to "apply." In most cases, they're the same, but there is a subtle conceptual difference that can have implications for how they are used. When we run

(apply + [1 2 3 4 5])

This is equivalent to

(+ 1 2 3 4 5)

Whereas, when we run

(reduce + [1 2 3 4 5])

This is equivalent to

(+ 5 (+ 4 (+ 3 (+ 1 2))))

As I said, this will end up the same way in most cases. But it is helpful to know what each function is actually doing, in case you run into any errors that can only be solved by drawing a nice distinction.

So we can reverse things and use apply to get stuff out of vectors so we can operate on their terms one at a time. The last thing to learn is how to turn things into vectors. If you want to turn a string into a vector, use the vec function:

(vec "abc")

Which returns [\a \b \c]. But turning that into a list runs into some issues:

(list [\a \b \c])
=> ([\a \b \c])

(list "abc")
=> ("abc")

Darn! It seems that running the list command only takes the whole thing and puts it into a list, instead of breaking it into a list of many characters. If only there were some way to pull all the characters out of the list, or out of the vector, and apply the "list" function to them one at a time!

Oh, right:

(apply list [\a \b \c])
=> (\a \b \c)

(apply list "abc")
=> (\a \b \c)

You can also coerce these things back into being strings. Obviously, you don't just apply the str command, because if you do:

(str [\a \b \c])
=> "[\\a \\b \\c]"

I shouldn't have to say what the solution is at this point. How do you pull each character out of the vector and apply str to it recursively?

SUMMARY: in this chapter, we explored lists and vectors, which are important because they're the primary data structures that can hold multiple items. This especially applies to vectors. We also learned about the conjoin, nth, subvec, assoc, and contains? methods and how to use them. In the next chapter, we'll take a look at maps.

CHAPTER 5: MAPS

A map, also known as an associative array, is a data structure that basically consists of two subsets: keys and values. A map has a set of keys, and a set of values, and each key points to a value. In Python, a map is called a "dictionary," because the relationship between keys and values is very similar to the relationship between words and their definitions in a dictionary. Maps are very important in computer programming because there are many, many problems that maps can solve. In this chapter, we'll find out how to define a map, learn some functions that can be called on maps, and then learn some basic problems that can be solved using maps.

The best way to learn what makes a map different from a list or a vector is the define one in your REPL and play around with it a bit, and that is precisely what we're going to do. You may have already noticed that there are quite a few different ways to do most things in Clojure. This isn't like Python, where there is generally one correct and obvious way to do things. Very often, how one does a thing in Clojure is a matter of taste. Other times, there are many ways to do a thing, but there is one way that is idiomatic or stylistically correct. So keep in mind that how we define maps here is just one way of doing so. Now, to start off, open your REPL and type in the following: 

(def m (hash-map :a 1 :b 2 :c 3 :d 4 :e 5))

There are a few different things going on here, so let's dissect that first line of code. First, you may have noticed the letters with colons before them, :a :b :c etc. These are what are known as keywords. This is a special data type in Clojure that always evaluates to itself. There is tremendous utility in a data type that simply evaluates to itself, and we're about to see one use of it here. Keep in mind that keywords need not be a single letter. You can define keywords such as :foo or :bar or :fuzzywuzzywuzabear and they will always evaluate to themselves. Try typing :foo into your REPL to see what happens. You'll notice that it returns :foo, simply evaluating the expression to itself.

If you type m into your REPL, it will return the following, or something like the following:

{:c 3, :b 2, :d 4, :a 1}

I say "something like" the following because maps are not an ordered data type. More on that in a moment. For now, let's just see how keys and values work. Try the following in your REPL:

(m :a)
(m :b)
(keys m)
(vals m)
m

The first two lines make it clear what's going on here. When you call a map like a function and pass an argument to it, if that argument is in its list of keys, it returns the value for that key. The key :a is associate with the value 1, and the key :b is associated with the value 2, and so on, so calling the map like a function and feeding it :a or :b will return the proper values. The keys function will return a list of all of m's keys, and the values function will return a list of all of m's values. Simply typing m will return the whole map.

I said a moment ago that maps are not ordered, which is to say, it doesn't matter what orders you type the items in. Unlike, say, vectors, which are ordered, the items in a map do not have any order in particular. To demonstrate this, try the following in your REPL:

(= [0 1 2] [2 1 0])

You will notice that this returns false. Even though these vectors contain the same terms, the terms are not in the same order, so Clojure sees two different vectors here. For vectors, it's important what order the terms are in. If two vectors contain the same terms (in this case, the numbers 0, 1 and 2) but those terms are not in the right order, then you're dealing with two completely different vectors, not equal in any sense. But with maps, the situation is different. Map keys-value pairs do not lie in any specific order. Vectors and lists are sort of like the cars on a train, that are linked together in a specific order. The set of keys or values in a dictionary, by contrast, is like a bag of marbles. The things in the bag do not have any specific linear order. They're just sort of "in the bag." Accordingly the equality function for two maps will return "true" even if they are in a different order, so long as they have the same key-value pairs. Try this in your REPL:

(= {:a 1, :b 2, :c 3} {:c 3, :b 2, :a 1})

This returns true, because every key-value pair in the first map has a corresponding key-value pair in the second map.

I want to take a moment to warn the reader that it's not REQUIRED to use keywords for map keys. Strictly speaking, any item that can go into a collection can be a key or value. You can map integers to other integers, for example:

(def m (hash-map 1 2 2 3 3 4 4 5 6 0))
=> {1 2, 2 3, 3 4, 4 5, 6 0}
(keys m)
=> (1 2 3 4 6)
(vals m)
=> (2 3 4 5 0)

This map is best understood by visualizing it as a table:

KEYS	|VALUES
________|______
1	|2
2	|3
3	|4
4	|5
6	|0

THere's nothing stopping you from relating vectors to lists or lists to integers or even other maps to keywords. You can map more-or-less anything to more-or-less anything else. Try these in your REPL:

1. (hash-map 1 [2 3 5] 2 [7 11 13] 3 [17 19 23])
2. (hash-map :primes [2 3 5 7] :!primes [1 4 6 8 9])
3. (hash-map :a [0 0 0] :b [0 0 0] :c [0 0 0])

The first maps 1 to a vector containing the first three prime numbers, 2 to the next three primes, and 3 to the next three. The second maps the keyword :primes to all the primes under 10, and :!primes to all the nonprimes under 10. The third is a simple implementation of a tic-tac-toe board. :a is the first row, :b is the second, and c: is the third. If we wanted, we could write some functions and use that map as the basis for a simple text-based tic-tac-toe game that could run in terminal.

One final word: calling (<map> <key>) is the most parsimonious way to acquire the value for a key. You can also use the get function, thus: (get <map> <key>). One cool feature of the get function is the default. If you type (get <map> <key> <default>), it will return the value for that key, and if the key is not found, it will return the default argument, whatever that happens to be. Try this in your REPL:

(def m (hash-map :a 1 :b 2 :c 3))
(m :a)
(get m :a)
(get m :a "Key not found")
(get m :z "Key not found")
(m :z "key not found")

You'll notice that, since :z is not a key of m, it returns "key not found." Moreover, the default argument can still be passed even if the "get" function is omitted. Generally speaking, it looks cleaner to omit "get', but it can perhaps be less ambiguous and easier to read to include it. Whether or not you want to prioritize parsimony or readability will, of course, depend on the individual piece of code that you're writing at a given time.

CHAPTER SIX - STRING MANIPULATIONS

Much of the data that you run into while programming is going to be in the form of text. Clojure programs, although they turn into different kinds of code when being compiled or run, begin their lives as text files. Websites are represented by HTML and CSS, both of which are stored in document form as text files. Most APIs will provide their data represented in JSON format, which typically comes as a text file if you download it. And it's not just JSON: many, many different formats exist for representing data as text. Nearly every piece of data that is meant to be human-viewable can be represented in text. That all means that, if you want to manipulate data, you need the ability to manipulate text files. Later on, when we scrape websites, much of the information that we take from them will be stored as text, and that information will be parsed as text. Since Clojure uses strings for holding text, we'll be using the string and char data types a lot, and it behooves us to know how to use them.

Additionally, strings are important because Clojure is homoiconic. Homoiconicity is a fancy computer science term for a program that treats its own code as data. That is to say, a homoiconic language can manipulate code written in that language. A Clojure program can, if written correctly, write another Clojure program. Clojure code is homoiconic, so it can generate more Clojure code. More fundamentally, though, the homoiconicity of Clojure means that the "internal representation" of the program has the same structure as the "external representation." This can all sound very jargon-laden and sciencey and intimidating, but never fear: once you grasp the fundamentals, it will all seem quite easy.

The external representation of a program, simply put, is the source code. The code that you type into emacs (or vim, or an IDE) is the external representation of the program, the stuff you see in front of your eyes on the screen. The INTERNAL representation, by contrast, is what the computer does with it once it evaluates the source code, such as while compiling or interpreting or, well, running the program. The external representation is always put into a form that a human can read or understand. The internal representation has to do with what's going on "under the hood," what's happening inside of the computer; you could almost think of it as the way that the computer represents information to itself, when it doesn't have to worry about the information being readable by a person. The power of LISP languages, of which Clojure is one, is that these two representations have the same structure. The internal representation is put together in a similar way to the external representation. The different parts of the internal representation and related to one another in the same way as the different parts of the external representation. Those parentheses that you've been writing this whole time have a fancy name: "s-expressions." The internal representation of Clojure code is made up of S-expressions, and so is the source code itself. A fluffy metaphorical way of putting this is that Clojure sees itself the same way that you see it. Clojure JUST IS the symbol that represents it. Homo-iconic, from the Latin roots, "same" and "picture." The picture of Clojure is Clojure itself. Thus, Clojure programs can generate other Clojure programs and treat them as data. This is primarily done through something called "macros" which we'll examine in the next chapter. But first, we're going to learn about strings.

You can make any piece of text into a string literal using a single quote, or by using the quote function. A string literal is a string that Clojure takes literally, rather than evaluating it. So instead of reading "n" as a symbol, Clojure can read it as a string, reading it literally. This can be done by typing 'n or (quote n). Try the following in your REPL:

1. (def n [1 2 3 4 5])
2. (print n)
3. (print 'n)
4. (print (quote n))

Notice how 2 evaluates n as a SYMBOL and prints out the vector [1 2 3 4 5], which is what n stands for. 3, however, does not evaluate n at all, and merely prints out n, as does 4, which is equivalent. To see how you can use this in tricky ways, try the following in your REPL:

1. (print (print))
2. (print '(print))
3. (def j [1 2 3])
4. (print [j j j])
5. (print ['j j j])
6. (print ['j 'j 'j])
7. (print '[j j j])

Notice that 6 and 7 return the same thing. This is because they are equivalent. Putting a single quote at the beginning of the entire vector quotes everything in the vector, as does putting a single quote before each individual item. This will be important in a moment, because we're going to learn how to use it to import namespaces. Many of Clojure's string manipulations require importation of the Clojure string namespace. Before we learn to import it, however, let's learn about the two important string operations that can be done without it. Namely, indexing and string slicing.

Indexing strings is done in much the same way as indexing vectors or lists. All three of these things - strings, vectors, and lists - are collections, and they all implement the collections class in Java, so the indexing function nth works on all of them. In the case of vectors and lists, the nth function returns whatever is at the nth index; if that thing is another vector, or another list, or a character or string or symbol, it is returned by the nth function. In the case of strings, however, nth always returns a character. Try the following in your Repl:

(nth "Function" 0)
(nth "Function" 7)
(nth "Function" 4)

You'll notice that these lines return, respectively, \F, \n, and \t. The nth function always returns a character when a string is the collection passed thereto.

Now for string slicing! String slicing can be done in one of several ways. The string slicing we do with regular expressions will have to wait for a few chapters. However, if we want to slice a string into substrings just using indices, then we can use the subs function. To do this, we're going to define a symbol as a string, just for ease of typing.

1. (def s "Live your life as though your every act were to become a universal law.")
2. (subs s 25)
3. (subs s 25 39)
4. (subs s 0 15)
5. (subs s 0)

Notice that 2 and 5 both return the string from the first index to the end. Since 5 begins at 0, it returs the whole string. However, if a second argument is passed to the subs function, it adds a stopping point. This allows you to slice the string up any which-way you please.

Now to import a namespace. Namespaces can be imported like so:

(ns auto.the.bs
(:require [clojure.string :as str])

The structure of that is:

(ns <whatever.namespace.you.want>
(:require [clojure.<namespace> :as <something-short-and-easy-to-type>]))

The <whatever.namespace.you.want> after ns carves out a namespace for your program. The :require keyword tells Clojure that your namespace requires whatever namespace is specified in the brackets. clojure.<namespace> is the namespace you're requiring. :as tells Clojure how you want to refer to that namespace from here on out (what you want to type to call functions from it), and <something-short-and-easy-to-type> is something you can type in place of the namespace's full name. Normally, we would have to call functions from clojure.string by typing clojure.string/<function>. But since we imported the whole thing as str, we can just type str/<function>.

So now that we've imported a namespace, we can ask: what did we just do, exactly? The answer is that a namespace in Clojure works very similarly, for the purposes of writing code, to a module in Python. Importing the namespace gives you access to a library of functions defined in that namespace, and these functions do a lot of the stuff that you want to do with strings. This spares you the pain of re-inventing the wheel every time you want to see which character a string begins with or change a string to upper case, because those functions have been written for you, and they're included in the string namespace.

For the rest of this chapter, I will assume that you have begun each REPL exercise by typing

(ns auto.the.bs
(:require '[clojure.string as string]))

at the beginning. The first few REPL exercises, I will remind you by including a 0th step that tells you to import the namespace. Afterward, though, you'll need to just remember that all of these functions come from clojure.string. Remember that you can get a line break without triggering the REPL to read by holding down shift when you press return or enter.

Our first function will be includes? which lets us find out if a string includes a substring. The process of using it is simple enough: we type out whatever imported the namespace as, following by a slash and then the function. We imported clojure.string as str, so we can call the function with (str/contains <string> <substring>).

0.	(ns auto.the.bs
	(:require [clojure.string :as str])

1. (str/includes? "What?" "W")
2. (str/includes? "What?" "?")
3. (str/includes? "What?" "hat")
4. (str/includes? "What?" "zebra")
5. (str/includes? "What?" "w")
6. (str/includes? "What?" "A")

You will notice that 1 through 3 all return true, because W, ?, and hat are all substrigs of the string. However, 4 through 6 all return false, because there is no word "zebra" or lowercase w or uppercase A in the string. This is how you know that the str/includes? function is case-sensitive. This could shape up to be a problem. What if we wanted to know whether or not a string contains a letter w, capital or no? We could use the horribly clunky

(or (str/includes? "What?" "W") (str/includes? "What?" "w"))

But that is either idiomatic nor fun to use nor easy to read. This can be done with regular expressions, which we haven't learned yet, but there is an acceptable way to do so without them: simply use upper-case or lower-case. Try the following in your REPL:

0.	(ns auto.the.bs
	(:require [clojure.string :as str])
1. (str/upper-case "What?")
2. (str/lower-case "What?")
3. (str/includes? (upper-case "What?") "W")
4. (str/includes? (lower-case "What?") "w")

1 returns the string trasformed to a rather alarmed-soundin upper case (WHAT?) while 2 returns a much more casual lower-case (what?). 3 and 4 both return true, because the string being checked for inclusion has been transformed. This is a down-and-dirty way to achieve case-insensitivity without regular expressions.

To check if a string is all uppercase or all lowercase, we can use a number of methods. Studiously excluding methods involving importig Java methods or using regular expressions, we can simply use:

0.	(ns auto.the.bs
	(:require [clojure.string :as str]))
1. (defn is-all-upper
	[s]
	(= s (str/upper-case s)))
2. (is-all-upper "NOUMENA")
3. (is-all-upper "phenomena")

2 should return true and 3 should return false. An analogous function can e created using str/lower-case. I will leave this as an exercise to the reader.

Next in line are starts-with and ends-with. These functions do exactly what they say on the tin: check if a given string begis or ends with a given substring. Try them out:

0.	(ns auto.the.bs
	(:require [clojure.string :as str]))
1. (str/ends-with? "critique of pure reason" "reason")
2. (str/starts-with? "immanuel kant" "immanuel")
3. (str/ends-with? "time" "time")
4. (str/starts-with? "time" "time")

Notice that the substring can be any number of characters from one to the length of the whole string, and still return true. The string "time" technically does end with "time" if you define "end" as "has the same letters counting backward along the entire substring." Which is precisely what str/ends-with? does.

Now for splitting strings! We can split strings using one of two functions. For strings with newlines, we can use str/split-lines. Try this:

0.	(ns auto.the.bs
	(:require [clojure.string :as str]))
1. (def s "There once was a man from Nantucketn\nWho spent all his days in a bucket")
2. (print s)
3. (str/split-lines s)

You will see that 2 prints out the first two lines of the limerick with a line break, while 3 returns both lines as separate items in a vector. This utility is extremely useful if you were, say, parsing a document with newline characters and needed to search each individual line for something in particular.

We won't be learning regular expressions until later, but there is one regex-based line that you should learn, which is the str/split function. It has the structure, (str/split <string> <expression>). Try this:

0.	(ns auto.the.bs
	(:require [clojure.string :as str]))
1. (def s "ABC")
2. (str/split s #"")

This should return a vector with "A" "B" and "C" as its items. So if you want to split a string into every single character, str/split is the way to do it. We'll learn later on what in the world that hashtag # symbol is for.

CHAPTER 7

A regular expression is a way for us to tell the computer to find something in a text document for us. While using a word processor or web browser, you've probably used ctrl-f to look through documents and web pages to find words. Regular expressions are similar, but rather than demanding entire words, they only ask for patterns. It is nearly impossible to overstate the value of regular expressions. Since most of the data you deal with while developins either is, or can be represented as, text, the ability to do sophisticated pattern-matching is key to working quickly and efficiently with data.

There are lots of patterns for things you may want to find in a text document. If you want to look through text and find only those things that are formatted like an email address, you can use a regular expression to find <anything>@<anthing>.<anything>, and then look through all the strings in the editor that match that. You could also use this to fine phone numbers, by searching for any number formatted like this: xxx-xxx-xxxx.

To demonstrate the power of regular expressions, let's create a program that searches a string for a phone number and returns that phone number. We'll start with a regex that just finds a digit in a string of letters, and then move on to the phone number regex. First, try this in your REPL:

(re-find #"\d" "abcdefghij3klmnop")
(re-find #"\d" "aaaa2bbbb")
(re-find #\d" "5catbag")

These functions, respectively, return 3, 2, and 5. So, how did Clojure know which one was the digit? As you can probably guess, it has to do with that weird string with the hashtag at the begining. That thing is our regular expression. The # tells Clojure that it's a regex and not just a regular string. The symbol, \d, means "any digit." That means the regular expression will hunt through the string, looking for a single digit, and return whatever digit it finds. Regexes can also be used to return a digit followed by a particular letter. Try these in your REPL:

(re-find #"\dV" "ab2hdi3c5Vnnnk13")
(re-find #"\d\d" "a2b3c5d7e11")
(re-find #"nk\d" "asdf5544nk3pot")
(re-find #"\d\d\d" "11a22b33c")

You'll notice that the first function returns 5V. This is because the regex #"\dV" searches for the first digit in the string followed by a capital V. The second expression returns 11, because the regex #"\d\d" looks for two digits in a row, and the only place where that occurs in the string as at the very end, with 11. The third expression returns "nk3", because the regex #"nk\d" searches out the letters nk followed by a digit, which, in this string, is nk3. The fourth regex, #"\d\d\d", returns nil. Can you guess why? Because it's looking for three digits in a row, but there's no place in the string where that happens.

It's time to hunt down phone numbers. Fire up your REPL and type in this:

(defn find-phone
	[text]
	(re-find #"\d\d\d-\d\d\d-\d\d\d\d" text))

Press enter to define the functio. We now have a function called "find-phone" which will pluck out anything formatted like a phone number and display it for us. Try running this:

(find-phone "blah blah gurfa blurfa 235-711-1317")

You will see that this returns the phone number 235-711-1317. So, how did it do that? You should be able to guess by now. IT's looking for a string composed of the following: three digits, a dash, three more digits, another dash, and then four digits. Now, this whole regex can be made much simpler using braces. The regular expression,

#"\d\d\d-\d\d\d-\d\d\d\d"

Is exactly equivalent to

#"\d{3}-\d{3}-\d{4}

This saves us a little time by allowing us to just enter a digit for how many digits we want. But wait - what if we have some phone numbers that are missing the dashes? There are a few different ways to tackle that issue and make sure we don't miss those numbers. This brings us to the really fascinating and powerful - and at the sime time, frustrating - features of regexes: there are multiple ways to do everything. This can be very interesting and powerful because it gives an adroit developer all kinds of options. At the same time, it can also be very frustrating and dangerous. Frustrating, because you can easily become paralyzed trying to find the optimal way to do something. And dangerous, because you can easily end up doing something in a suboptimal way; there are so many options that it's easy to pick a bad one.

One way to correct our last regex to something that can detect phone numbers is to add an expression that detects just any 10 digit number. That would look like this:

#"\d{10}"

But now we fail to detect phone numbers formatted with dashes. Fortunately, we can correct this problem using the pipe, or vertical bar, as it's also called: |. The | operator is a logical "or," so #"a|b" detects a or b in a string. We can also create GROUPS within regular expressions using parentheses. Using both of these, we can find both kinds of phone numbers:

#"(\d{3}-\d{3}-\d{4})|\d{9}"

The parentheses turns the string of digits and parenthesis into one group, and the pipe operator says that this regex will return the first thing it finds that matches one of the expressions on either side. Clojure will go through the string and check each part of it to see if it matches either side of the pipe, and when it finds a match, that match will be returned. Let's put our new regex to work:

(defn find-phone 
	[text]
	(re-find #"(\d{3}-\d{3}-\d{4})|\d{9}"))

(find-phone "blah blah blah 9998887777")
(find-phone "gurb jurb 711-131-7232")

If done correctly, the find-phone function should return both phone numbers here.

Let's try something a little different. Let's say we have a huge mass of digits, but somewhere, there's a non-digit. It might be a slash, dash, letter, or plus sign, an asterisk, anything. To find that non-digit, we simple use the \D operator, which will find us anything that is NOT a digit. Try this:

(re-find #"\D" "12345*9857")
(re-find #"\D" "0987F32321")

These two will give us, respectively, * and F, because those two are the non-digit characters. So, \d gives us digits and \D gives us everything EXCEPT digits. \w gives us all alphanumeric characters (all letters and all digits) while \W gives us only non-alphanumerics, such as symbols. Try these:

(re-find #"\w" "&&$x$")
(re-find #"\W" "abc@123")

Continuing the include/exclude theme, \s grants any whitespace, i.e. any space or tab, while \S gives us any non-whitespace, meaning anything that ISN'T  space or tab. Try these:

(re-find #"\s" "abc def")
(re-find #"\S" " k ")

Let's return to our old friend, the braces. We know that #"V" returns the first occurence of the letter V. And we know that #"V"{2} returns the first place where V occurs twice in a row. But what if we did this: #"V"{2,3}? This would return any place where V occurs two or three times in a row:

(re-find #"V"{2,3} "cdVVV")
(re-find #"V{2,3}" "VVVabcVV")
(re-find #"V{2,3}" "VVabcVVV")

You'll notice that that second string contains both a group of 3 V's, and a group of 2 V's, i.e. VV and VVV. The regex returns VVV. Meanwhile, the third regex returns VV. The third regex returns VV because the string of two V's is the first matching string the regex finds, so it never goes all the way and matches the VVV at the end.

The astute reader will notice that, because the second line contains a string that begins with three Vs, the regex should, by rights, return two Vs. Obviously, every string of three Vs also contains two Vs. Every VVV is just a VV plus another V. So, why does Clojure return VVV instead of VV? Why do we get VVV for:

(re-find #"V{2,3}" "VVV")

Whe it could just as easily return VV? The answer is that regular expressions in Clojure, by default, are GREEDY. When #"VVV" encounters a string of digits VVV, it returs the entire match. IT won't return VV, because VV in this case is a substring of VVV, so the GREEDY regex returns VVV. If, however, we do this:

(re-find "V{2,3} "VVabcVVV")

then we see that VV is returned, because that's the first match the regular expression runs into. If this is all confusing, think of it this way: a regex's first priority is to return whatever match it finds first. But a greedy regex's secod priority is to return the largest string it can, while a non-greedy regex's priority is to return the shortest string it can.

If we omit the second number in the curly braces, we can give the regex a lower bound, but no upper bound. Try these:

(re-find #"V{1,}" "abcdeVVV")
(re-find #"V{3,}" "aVaVVaVVVaVVVVVV")
(re-find #"V{2,}" "V")
(re-find #"\d{0,}" "012")
(re-find #"\d{0,}" "0123456789")
(re-find #"\d{3,}" "0123456789")
(re-find #"\d{5,}" "0123")


Notice how this operator works. By only specifying a lower bound, we can only match strings of a certain length or greater.

Another important tool is the class. A set of braces {} can create a delimeter for us, and a set of parens () can enclose a statement for us to create a group. But we can also use brackets [] to create a class. Classes can contain many different things. For eample, we can search only for lowercase letters like so:

(re-find #"[a-z]" "1234k")

This will return the k because a-z specifies only the lowercase letters, a to z. We can also, if we so choose, limit this, e.g. to between a and g by typing #"[a-g]". We can also use ranges of numbers #"[0-9]" which is equivalent to \d. We can even mix and match to find, say, capital letters or numbers between 3 and 6: #"[A-Z3-6]".

The problem with classes, as we've defined them, is that they only match once. We can say, [B-De-g0-3] to match any of the following: BCDefg0123. But it would only match once, and return a single character, instead of matching a whole string. Obviously, we want to do a lot more with our regexes than just check for single characters! So let's use some quantifiers.

We've found one quantifier in the form of {a,b}, and indeed, that quantifier works with classes:

(re-find #"[B-De-g0-3]{1,}" "abcdEF4BDfe320xxxxx")
=> "BDfe320"

(re-find #"[B-De-g0-3]{3,4}" "abcdEF4BDfe320xxxxx")
=> "BDfe"

But there are other quantifiers we can use. Namely, the * quantifier, which matches any string where the quantified pattern occurs zero or more times, and +, which matches any string where the quantified pattern occurs one or more times. so #"[a-c]*" matches any string where the letters a,b, or c occur in some combination any number of times. Try this in your REPL:

(re-find #"[a-c]+" "aa")
(re-find #"[a-c]*" "aaa")
(re-find #"[a-c]+" "aaaaa")
(re-find #"[a-c]*" "aaaaabbbccc")
(re-find #"[a-c]+" "ddd")
(re-find #"[a-c]*" "ddd")

The astute reader will notice that, of the final two expressions, the penultimate one returns nil, while the ultimate one returns "". This is a very important difference! "" is, after all, a string, even if an empty one, while nil is just nothing. You can, for example, run the final expression on a string with no match, and conjoin the result to some other string, and get a string back. But if you tried this with the second-to-last expression, you would get an error, because while an empty string can be conjoined to another string, nil cannot.

The period . matches anything. The period followed by an asterisk #".*" matches anything and everything, the entire string, no matter what it is... unless it's a newline. A newline character is the only thing this expression will not swallow.

Classes have another important property, which is that we can attach a caret ^ to the inside of a class to exclude whatever is in the class and search only for those things NOT in the class. So while [0-9] is equivalent to \d, [^0-9] is equivalent to \D. This can be used with any class: [^b-f] will find any character in the string besides b, c, d, e, and f. 

Finally, we have so far been matching our regular expression to any text in the line. It is possible to anchor regular expressions, or groups withing regular expressions, to the beginning of a line, or to the end of one. To anchor a regular expression to the beginning, we use a caret ^ outside of brackets. ^abc[.*]

After reading this chapter, it probably occurred to you that patterns can be matched in multiple ways. When is it right, for example, to use .* in a regex rather than, say, [^\s]{10}? The answer - which is a general principle of writing regexes - is that, all things being equal, the more long and complex the regex is, the better. The reasoning here is that regexes expend much more time computing strings they do NOT match than the ones they DO match. The nitty-gritty of regex processing varies between implementations, but the general gist is this: a more specific regex is more predictive. It can more quickly recognize when the text it is processing does not match, and this significantly reduces processing time. It may FEEL as though you're being concise when you write a compact regex of only a few characters that matches the strings you want, but you can speed up your processing by orders of magnitude if you write specific regexes. Processing power should be our first concern whenever we think that our regex will, or may, be used to process large amounts of data. If computing power is not a concern (or if we're choosing between two regexes with similar resource consumption) then our next concern is readability. If we are searching through a textfile for an email address, and we need a quick regex that will only be searching relatively small files, we'll try to keep it readable.

CHAPTER 8

Input validation may not be the first thing you conceive of when you're excitedly planning a new app or project in your head, but it has to be done for most programs of any complexity. The reason is that you have no control over what the user will input into the program, so you have to make sure that the input is right so that the program does not crash. Even worse, failure to validate (or 'sanitize') user inputs can lead to problems:

(panel showing table-dropping SQL attack xkcd comic)

So let's begin by revisiting user input. User input in the command line in Clojure is typically taken using the read-line function. To test this out, try using the following code, which will simply echo whatever you type at the prompt:

(print (read-line))

Unlike certain other high level languages, Clojure does not have a dedicated library for user input validation at the time of this writing. So, in order to accomplish user input validation, we're going to write our own functions. Try this in your REPL:

(let [x (read-line)]
	(print x))

This does exactly what the previous expression did, with one vital difference: now that we've assigned a name to the user input, we can easily operate on it. We'll begin with arithmetic operations. However, even that basic attempt will hit a snare when we try the following:

(let [x (read-lie)]
	(+ x 1))

That throws an error because the user input becomes a string, which makes x a string. Oops! Recalling that Clojure runs on the JVM, we have access to everything that Java developers do. Therefore, we can use the Integer/parseInt functionality from Java. Try these in your REPL to see it in action:

1. (type "3")
2. (Integer/parseInt "3")
3. (type (Integer/parseInt "3"))

You'll notice that Integer/parseInt takes the string and converts it to an integer. This allows us to take user input and do arithmetic with it:

(let [x (read-line)]
	(+ (Integer/parseInt x) 1))

Now, go ahead and use emacs to open a file called validateinput.clj and write this in it:

1	(println "Enter your age.")
2	(defn get-age [flag]
3		(if flag (println "No, enter your REAL age."))
4		(let [x (Integer/parseInt (read-line))]
5		(cond
6                	(<= x 0) (get-age true)
7                	(> x  0) (print "In one year, you will be " (+ x 1)))))
8	(get-age false)

This is a bit more complex than mest of the programs and scripts we've written in this book thus far, so let's go through it line by line. Line 1 prints out "Enter your age." to prompt the user so they know that they are being asked to type omething. Line 2 defines a function called get-age with a single boolean parameter called flag. When we first call this function, we will pass false to it as an argument to avoid triggering line 3. Line 4 uses the let keyword to feed user input into the Integer/parseInt function, and then x is allowed to stand for whatever integer comes from that. Line 5 is the cond flow control, so we know one of two conditions will execute. Line 6 triggers if the person 0 or any number less than 0.

Line 6 introduces recursion into the program, because it's the line where the function calls itself. Because of how we wrote the flow control logic, using the cond statement, the function will terminate by calling itself. Since flag is set to true, the code on line 3 triggers and says, "No, enter your REAL age." This is because the user entered an age of 0 or less. If the user does so again, the function will simply call itself again with flag set to true, and repeatedly ask for the user's real age until they type a positive number. This triggers the condition on line 7, which prints out how old the user will be next year. The loop terminates because this condition does not involve the function calling itself.

So far we've learned how to make sure that user input is falls within a certain range, and do arithmetic tests on it. You could just as easily use the tests above with the even? or odd? functions, or any of the other arithmetic predicates. There are a few other tasks to handle, including the treatment of blank inputs, but first, I want to say another word about recursion.

The function I just showed you is not idiomatic. It's not WRONG, per se, since it does work and it will do what it's supposed to do. But there are better ways to use recursion, most notably with recur. I wrote that first function the way I did because it was easier to understand than doing it idiomatically. The idiomatic way, however, is this:

1	(defn get-age [flag]
2	    (if flag
3	      (println "No, enter your REAL age.")
4	      (println "Enter your age!"))  
5 	    (let [x (Integer/parseInt (read-line))]
6        	(cond
7          		(<= x 0) (recur true)
8          		(> x  0) (print "In one year, you will be " (+ x 1)))))

This function does exactly what the previous one does, with a vital difference. The first function I showed you calls itself explicitly (get-age true) which means that the computer has to hold the function in memory every time it makes a new nested call. If you type 0 many times in a row, you will eventually get a stack overflow error. The nice thing about the recur keyword is that it allows you to accomplish recursion without consuming the stack. When you give it the recur keyword, Clojure will evaluate the entire function, and then re-execute using whatever arguments are passed to recur, without holding anything on the stack.

Returning to input validation, it ultimately comes down to what you can reasonably expect from your user. Ordinary people are not computers and will make typos, type the wrong thing in the wrong field, type spaces between numbers, hit the enter key without typing anything, and make a whole host of other mistakes. Instead of trying to anticipate literally every single wrong input we might receive - which would just paralyze us and keep us from ever writing any code - it makes more sense to deal with specific mistakes that we know to be common. Accordingly, instead of asking ourselves, "What are all the different things that can be passed to this function?" it makes more sense, at this stage, to ask, "What are the mistakes that a human user could make while using this?"

One example is blank input. How could we re-write the function above to deal with blank input? Well, when a user hits enter without typing anything in response to the read-line function, the value that the string would be assigned to is assigned an empty string rather than nil. So if a function contains (let [x (read-line)] (print x)) and the user hits enter without typing anything, x will be set to "", not nil. So if we want to account for the possibility that the user could just tap enter without typing anything, we can use the following function:

1	(defn get-age [flag]
2		(if flag
3			(println "No, enter your REAL age.")
4			(println "Enter your age!"))   
5		(let [x (read-line)]
6			(cond
7			(= x "") (recur false)
8			(<= (Integer/parseInt x) 0) (recur true)
9			(> (Integer/parseInt x)  0) (print "In one year, you will be " (+ (Integer/parseInt x) 1)))))


You'll notice that the Integer/ParseInt has been removed from its former place on line 5 and iserted into lines 8 and 9. This is because Integer/ParseInt throws an error when passed an empty string. So we allow x to just be the raw read-line input, test that to see if it's an empty string, and then convert it into an integer on an as-needed basis.

The next thing to learn is using limited tries. Perhaps we want to stop our user from entering anything if they fail to enter a valid input a certain number of times. You see this a lot on the internet where you can be locked out of an account for a certain length of time if you enter the wrong password too many times. Naturally, we want to take care of this by adding a counter:

1	(defn get-age [flag cnt]
2 	  (if flag
3	     (println "No, enter your REAL age.")
4     	     (println "Enter your age!"))
5       	(let [x (read-line)]
6       	(cond
7         		(>= cnt 10) "Limit exceeded."
8         		(= x "") (recur false (inc cnt))
9         		(<= (Integer/parseInt x) 0) (recur true (inc cnt))
10        		(> (Integer/parseInt x)  0) (print "In one year, you will be " (+ (Integer/parseInt x) 1)))))

This adds a clause to the cond statement. Remember that only one condition can be triggerted in the cond statement, and that whichever one is triggered first ends the statement. The very first thing our cond statemnt checks is the value of cnt (count). If that is equal to or greater than ten, then the function terminates by returnig "Limit exceeded." Note that "Limit exceeded." is an implicit return. You will notice that, on lines 8 and 9, a recur statement occurs always at a place were the function would normally return a value. A recur value in that spot is said to be in "tail position," and such recursion is called "tail recursion."

CHAPTER 9 - READING AND WRITING FILES

Code is data in Clojure, because, as mentioned previously, the language is homoiconic, but we want to be able to store and read data. One way we can do this is by reading and writing from text files. The vast majority of the data you work with is in some kind of text format, so a software dev who is learning a new language shuold anticipate that at some point they will need to learn to read from and write to text files. To write to a text file, consider the following function:

0	(use 'clojure.java.io)
1	(defn write-to
2		[file text]
3		(with-open [wrtr (writer file)]
4			(.write wrtr text)))

Line 1 defines a function named write-to, and line 2 gives it two parameters: file and text. with-open is a function within Clojure.core that takes a vector and a body. The vector is the inside of the brackets on line 3: [wrtr (writer file)]. Let's dissect line 3 inside out. First of all, the innermost layer of parentheses is inside of (writer file), which takes whatever argument was passed to the file parameter and passes it to writer. This coerces it to a java.io.Writer object. This is what opens the file for the program to write to. So the (writer file) returns file, coerced into an open java.io.Writer object, and with-open binds it to the name "wrtr".

Finally, we come to line 4, where we have (.write wrtr text). There are a few things going on here that we have not seen before, so let's unpack them one at a time.

In the first place, calling the name of a function after a dot allows us to invoke functions from the Java libraries. This is a case of Java interoperation, or interop for short. In this case, we're importing java.io, which gives us access to the write function. We can call the write function using a dot followed by any arguments to the function, e.g. (.write wrtr text), which calls the write function and writes text to whatever java.io.Writer object is presently symbolized by wrtr.

Java interop has other uses as well, of course. For example, you can call the toUpperCase function from the string module, like so:

(.toUpperCase "text")
=> "TEXT"

In general, if a method is in a namespace that the present program has access to, and we want to call that method and pass an object to it, then we can use this syntax:

(.function object)

where we replace "function" with the function we wish to call and object with the argument(s) being passed to the function. We may also use:

(. object function)

For reading from files, we want to incorporate exception handling because it is very easy to try and read something, come back with null, and throw a monkey wrench into the whole process. Accordingly, we can write our next function like so:

0	(use 'clojure.java.io)
1	(defn read-from
2		[file]
3		(try
4			(println slurp file)
5		(catch exception e (println "Error: " (.getMessage e)))))

Breaking this one down line by line, we see that line 0 is the statement that gives us access to the clojure.java.io library. Line 1 is the function definition and Line 2 defines the parameter vector. Line 3 is a try statement: the function will attempt to read the contents of the file and print them out (yes, the command to read the contents of a text file really is "slurp"). If the function can successfully read from the text file, it will print the contents thereof. If not, the it will print "Error: " followed by the contents of the error message. Of course, if we want to simply return the contents of the file - say, to another function that handles them - then we would just delete println from Line 4 and have:

0	(use 'clojure.java.io)
1	(defn read-from
2		[file]
3		(try
4			(slurp file)
5		(catch exception e (println "Error: " (.getMessage e)))))

We could then write (println (read-from file)) in order to get the same result. In truth, the first example is merely illustrative. It makes much more sense to write a function that returns the contents of a file and then pass those contents to whatever function you want to use them, which would include the println function if that's what you wanted to do. This is a matter of simply not coupling one's tools too tightly.

If we want to append a line of text to a file, we use the following function:

0	(use 'clojure.java.io)
1	(defn append-to
2		[file text]
3		(with-open [wrtr (writer file :append true)]
4			(.write wrtr text)))

This creates a new line in the textfile, designated by a string passed as argument to the file parameter. It then writes the text passed as a string to the text parameter to that file.

