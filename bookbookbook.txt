CHAPTER ONE

To begin with, you'll want to install Clojure. Clojure runs on the JVM, which means we'll be installing Java first. What dependencies Clojure has will depend heavily on what OS you're running. The rest of this chapter will assume that you're running Linux. In particular, we're assuming that you're running some flavor of Ubuntu. A Debian-based or other distro may have slightly different requirements. On a Windows install, you will want to set up a Linux virtual machine to install Clojure on. If you just want to experiment with the REPL without actually writing full-length programs, repl.it has an in-browser Clojure REPL that you can use.
The dependencies for Clojure in this context are bash, curl, rlwrap, and Java itself. the sudo apt-get install command should suffice to install most of these on most Linux distributions. If that doesn't work, try running sudo apt-get update first, and then installing. Any further troubleshooting will depend on what version/distro of Linux you are working with.
Once everything has been installed, you can begin playing with Clojure by typing clj into your terminal. This initiates a REPL for closure. REPL stands for Read, Evaluate, Print, Loop. This is a very fancy way of saying that we have initiated an interactive shell for Clojure. What that means is that we can type in stuff from the Clojure language and see output in real time. We can type in functions, literals, commands, and so on, and watch the interpreter do stuff in real time. It is very similar to Python's interactive shell. The "read" part of REPL is where the interpreter reads our input that we type in at the command line. The Evaluate part of REPL is where the interpreter evaluates that input to produce output for us. The Print part of REPL is where the interpret takes the output and displays it on the command line. REPL: Read, Evaluate, Print, Loop.
Once we have the REPL open, we can mess with Clojure a little in order to see what various commands do and how the interpreter responds to different stuff from the Clojure language. You can begin by typing in some literals, such as 42, 42.0, "String", and so on. You will notice that literals evaluate to themselves, i.e the interpreter prints out whatever literal it was given as input.

The REPL will be our tool early on because it allows us to type in commands and try different things. You will remember these things much better if you actually do them instead of just reading about them. Much as a pianist will remember a scale much better if they sit down and actually play that scale, a software developer who employs the concepts that they are learning will retain those concepts much better than if they merely read about them.

To begin with, we'll start with the arithmetic operations, since these are the easiest and most basic operations. Open up your REPL and type this:

(+ 1 1)

And press enter. If you do so, the program will return,

=> 2.

What happened? Right of the bat, this looks a little different from the math you saw in school. Ordinarily, in your school mathemetics, the plus sign, as well as other OPERATORS such as the division and multiplication signs, went between numbers. But here, those operators go at the beginning, and the whole thing is enclosed in parentheses. What's going on here!?

To begin with, everything in Clojure is a function. Whenever you enclose something in between those two parentheses, you're not just categorizing it the way you do in algebra. Rather, every set of parentheses CALLS a function. That means that those parentheses say to Clojure, "Hey, you! See these parentheses? There's a function inside of here, which is a set of instructions for you to follow. Look inside of these parentheses and execute this function!" Every set of parentheses in Clojure is a function call. Functions in Clojure, as stated, are a set of operations or instructions, and zero or more ARGUMENTS. Think of the instructions and operations as a machine, and think of the arguments as a set of things that you put into one end of that machine. What comes out the other end of the machine is the result of applying those instructions to that argument. So when you type (+ 1 1), you're taking the plus + operation and feeding it two integers, 1 and 1, and having it add those together. The integers are the arguments to the function, and the function itself, in this case, consists of adding the arguments together.

Another difference between the operations you learned in school and the operations in Clojure, besides just the order you write them in, is how many arguments they can take. In school, you wrote addition like this: 1 + 1, and the result like this: = 2.The addition you learned in school is a "binary operation" or an operation that operates on two things, in this case the numbers on the left and right. Clojure addition, however, is not limited in this way. In Clojure, addition can operate on as many things as you want! So you can try typing the following into your REPL:

(+ 2 3)
(+ 3 5 7)
(+ 7 5 3)
(+ 7 11 13 17 19 23)
(+ 31)
(+)

And notice what happens. No matter how many arguments you put in, the addition operator will faithfully gather them all up and add them all together. And this works for all of the arithmetic operators, which are as follows:

+
-
/

These are addition, subtraction, and multiplication. There is no exponentiation symbol in Clojure, although there are, of course, ways to crete an exponentiation function, which we shall learn about later. To see how subtraction pans out, try the following:

(- 10 5)
(- 5 10)
(- 1 2)
(- 2 1)
(- 2 3 5 7 11)
(- 23 19 17)

Finally, we come to our third basic operator in Clojure, which works a little differently than you might think: division. Division in Clojure can be done differently depending on the kind of number you're dealing with. And this, incidentally, is a good place to introduce the two most basic types of numbers in Clojure: ints and doubles. Ints are integers, meaning simple numbers with nothing after the decimal point. Doubles are decimal numbers. Try typing the following:

(type 1)
(type 2)
(type 3)
(type 1.0)
(type 2.0)
(type 3.0)

The type function tells you what type of thing a thing is. The type function only takes one argument.

Now, the reason we've taken this little detour to talk about data types is this: how division works changes based on what kind of number you use. Using division on integers is very different from using division on doubles. Try the following in your REPL:

(/ 2 3)
(/ 4 6)
(/ 8 12)
(/ 6 2)
(/ 6 3)
(/ 2.0 3)
(/ 2 3.0)
(/ 4.0 6)
(/ 6.0 3)

You'll notice something interesting: what result you get back from the division depends on what kind of number you give it. If you give the division operator at least one double, you'll get back a double. So (/ 3.0 2) and (/ 3 2.0) both give you back 1.5. However, if you only give integers to the division operator, you'll get something else back. You'll either get an integer, if the denominator divides evenly into the numerator, or you get what is known as a ratio. The ratio is basically a fraction. It automatically reduces to its simplest form. Since 4/6 reduces to 2/3, running (/ 4 6) will yield the ratio 2/3.

Obviously, if all you could ever do was just feed a few arguments into a function, you would never get much done in Clojure. That's why functions can be composed, or put together, to make new things. Try the following in your REPL:

(* (/ 3 2) 2)
(/ (+ 5 7) 6)
(+ (/ 1 3) (/ 1 3) (/ 1 3))
(- 1 (/ 1 2))

Similarly to the algebra used in school, the inner parentheses are evaluated first, and then the results of those expressions are evaluated within the larger parentheses. Composing functions in this way is the brass tacks of how we build big things in Clojure.

There's one last data type you need to know about, and that is the string. A string is a sequence of characters. When we're scraping websites later on, string manipulation will be important, because a lot of the data that we download from websites will be in text form, which means it will be stored in strings. Try the following in your REPL:

"put"
(str "put " "it")
(str "put " "it " "all " "together!")
(str "with numbers, too, such as " 1 "!")

You'll notice that entering a string into the REPL returns a string, while using the str function sucks up any argument you put in there and then returns one big string of everything you fed the function.

Finally, variables. Think of a variable as an envelope, and of the value of that variable as the contents of the envelope. Variables store values. An envelope can hold a five dollar bill, or a ten dollar bill, but it is not, itself, a dollar bill. It can also change, where you take out the five dollar bill and put in a ten, or vice versa. You can even leave it empty! Variables are much more important in other programming languages, such as Java and Python, because many popular languages are "object oriented." This means that other languages have this notion of a 'stateful' object, or an object with states that can change. For example, in other languages, you might have a class that has a lot of different attributes that can all change. In Clojure, there is only one type of variable that you should use, and that is the atom. We define an atom using the def keyword, thus:

(def five-dollar-bill (atom 5))

Type those two, and then try the following in your REPL:

five-dollar-bill

@five-dollar-bill

(+ five-dollar-bill five-dollar-bill)

(+ @five-dollar-bill 5)

Notice what you get in each case? five-dollar-bill, by itself, refers to the container, the variable, while @five-dollar-bill refers to the variable, the thing inside of the envelope. Let's make another one. Try the following commands, one at a time.

(def dollar-bill (atom 1))

@dollar-bill

(swap! dollar-bill + 10)

The swap! function changes what's in the envelope for something else. In this case, it lets you add ten to whatever's in the envelope, which is like putting more money in there. You can also take money out:

(swap! dollar-bill - 10)

We can also define atoms as strings and add to those strings. Try the following, one at a time:

(def name (atom "Sir"))

(swap! name str " Arthur")

(swap! name str " Conan")

(swap! name str " Doyle")

@name

(reset! name "Edgar Alan Poe")

@name

(reset! name 1003401)

@name

It's always a good idea to use descriptive names in programming. You'll notice that the five-dollar-bill atom contained the value 5, while the dollar-bill atom, which changed values a lot, had a more general name. Meanwhile the variable containing strings containing the names of various famous authors was called "name" to reflect that. This is part of "style" or the conventions that software developers use to make sure their code is readable for other software developers.

Now that we've learned the nuts and bolts of Clojure, let's create our first Clojure program! To begin with, type "vim helloworld.clj" into your terminal. This will open a buffer. Press I to enter insert mode, and type the following:

;This program will say hello and then ask for your name
(println "Hello, world!")
(println "What's your name?")
(let [username (read-line)]
(println (str "Pleased to meet you, " username "!")))

Press the esc key, type :wq and then enter. :wq stands for "write quit," which will save (write) your file and then quit the program. Now that you're back to your normal terminal, try this:

clj helloworld.clj

And watch the magic! The program will print "Hello, world!" and ask for your name. Type your name, and it will greet you by name. Et voila! The program executes top to bottom and then returns to terminal when it's done.

Let's dissect this program and see what's going on under the hood.

First of all, we have this line:

;This program will say hello and then ask for your name

This is a COMMENT, which is just a note to anyone reading your source code telling them what the source code does. Then we have the following:

(println "Hello, world!")
(println "What's your name?")

This is the println function, which prints a line of text to the terminal and then enters a line break, so that whatever prints next is on a new line. The println function, in this case, takes a string as an argument and prints it out. The line break is there to make sure that whatever prints next doesn't print on the same line, which is why "Hello, world!" and "What's your name?" print on two separate lines. Next up is:

(let [username (read-line)]
(println (str "Pleased to meet you, " username "!")))

The 'let' keyword defines what is known as a symbol. This isn't one hundred percent accurate, but for right now, it's okay to think of a symbol as a variable that never changes. In reality, there is a more subtle difference than that, but for now, it's okay to think of it as an immutable variable, even if that's not QUITE what it is. The let keywork here works like this:

(let [symbol (thing)]

which means that we're saying, "Let this symbol stand for this thing." In this case, the thing in question is the read-line function, which tells the program to pause and wait for the user to type something and press enter. So whatever the user types, is what the username symbol stands for. Finally, we have

(println (str "Pleased to meet you, " username "!")))

You will remember that the str function takes all the stuff you give it and sticks it into one long string. But the word, username, is not in quotes. If it were inside of quotes then the println function would print out, "Pleased to meet you, username!" because it would think that username was just the insite of the string. But it's not, so it gets EVALUATED and the program looks past the symbol and grabs whatever the symbol stands for. So if the user types in "Bob" for their name, the program will say "Pleased to meet you, Bob!" instead of "Pleased to meet you, username!" because it understands that username is just a symbol for whatever the user typed in and not a literal string.

Before we wrap up this chapter, we have a few more functions to learn. The first one is count. You can use it to find the length of a string. Try this in your REPL:

(count "Artichoke")

And it will give you

=> 9

Now try these in your REPL, one at a time:

(count "")
(count "Psych! I'm actually a star-spider.")
(count "Eenie Meenie Miney Moe")

And see what you get back.

Finally, let's learn about casting, or, as it's known in Clojure, coercing. Coercing is a way of turning one data type into another. Try the following in your REPL, one at a time:

(type 9)
(str 9)
(type (str 9))
(type "9")
(int "9")
(type (Integer/parseInt "9"))

Notice how that works? The str function can take the long 9 and turn it into a string, and the type keyword tells you what's going on there. The type of 9 is long, but the type of (str 9) is a string. The type of "9" is a string, and (str 9) returns "9" and is thus equivalent to it. Ditto for (Integer/parseInt "9"). This is called coercing, and it will become important later when we have big text files and we're hunting through them for numerical data to feed into our functions. On the other hand, if we want to put a number into a string and write that into a text file, coercing the number into a string may turn out to be useful.

Now, let's finish up by adding a few more lines to our program:

;This program will say hello and then ask for your name
(println "Hello, world!")
(println "What's your name?")
(let [username (read-line)]
(println (str "Pleased to meet you, " username "!"))
(println (str "Your name is " (count username) " letters long.")))
(println "How many years old are you? Type a number.")
(let [userage (read-line)]
(println (str "You are " userage " years old, and you will be " (+ (Integer/parseInt userage) 1) " in a year.")))

Notice how the last few lines do not do anything new, but uses what we've already learned to expand on the original concept a little. Now it tells the user how old they are, and how old they will be in one year. Note how Integer/parseInt is used to coerce the string into becoming an integer so we can add 1 to it, and also notice how the str function near the beginning of the final line turns it all back into one big string.

SUMMARY
So far, we've learned how to do basic arithmetic in Clojure, how to cast different data types as one another, what are data types exactly, how to get user input, what are variables and atoms, and how to use a REPL. In the next chapter, we'll go a step further and learn flow control. Flow control will take much of what we're doing and put it together into a larger structure.

CHAPTER TWO - FLOW CONTROL

The program we wrote last chapter executed from beginning to end, top to bottom, like a grocery list, just going down the page and executing the instructions one at a time. Very few real-life programs work like this, though. In real programs, the computer makes decisions: it can execute a single instruction multiple times, skip some instructions, or choose which instructions to run. The means of doing this is called flow control, and it works in a manner very similar to a flowchart. Observe this diagram (see: flowchart.png).

This is an instance of flow control using what are known as if-else statements. First, we start with a situation where the computer does not work. IF it is not plugged in, THEN we plug it in. ELSE, we go to the next step and ask if the computer is turned on. IF it is turned on THEN we restart it. ELSE, we turn it on. This is an instance of flow control. In order to make a computer program that works like a flowchart, you need to have a way to represent truth and falsity, yes and no; "Is the computer turned on?" is answered with yes or no because it is either true or false that the computer is turned on. In this case, we are using what is known as boolean values.

A boolean operation turns on whether or not a value is true or false. Fire up your REPL and try the following:

(= 1 1)
(= 1 2)
(true? (= 1 1))
(true? (= 1 2))
(false? (= 1 1))
(false? (= 1 2))

You'll notice that (= 1 1) returns true and (= 1 2) returns false because 1 does not equal 2. (true? <statement>) returns true if <statement> is true, and (false? <statement>) returns true if <statement> is false. Clojure can return boolean values in many other ways as well, using these comparison operators:

=	|equals
not=	|does not equal
<	|less than
>	|greater than
<=	|less than or equal to
>=	|greater than or equal to

These are comparison operators that return boolean values when they compare two things. Try the following commands in your REPL, one at a time:

(not= 1 1)
(not= 1 2)
(< 2 3)
(< 5 3)
(> 5 7)
(> 7 5)
(<= 7 11)
(<= 11 7)
(<= 11 11)
(>= 7 11)
(>= 11 7)
(>= 13 13)
(= 17 17)
(= 17 19)
(= 19 17)

This should give you a good gut feeling for how these comparison operators work, but we're not quite done yet. You might have guessed by now that these comparison operators work differently depending on what data types you give them. A string is never equal to a number, for example. To verify this, try the following in your REPL, one at a time:

(= 0 "0")
(= "0" "0")
(= "0" "Clojure")
(= "Clojure" "Clojure")
(= "Clojure" "clojure")
(= 0.0 0.0)
(= 0 0.0)

However, even though different data types are never equal, some operators can, in fact, take operands of different types (an operand is just the thing an operator takes, e.g. a and b are the operands for a + b and the operator is +). For example inequality operators can take operands of multiple types. Try these in your REPL:

(<= 2 2.0)
(< 2 99.321)
(> 2 500)
(> 2.1 0)

In addition to comparison operators, there are also boolean operators, or operators that return a boolean value and take boolean values. The three boolean operators are AND, OR, and NOT. Try the following in your REPL:

(and true true)
(and false false)
(and true false)
(or true true)
(or true false)
(or false false)
(not true)
(not false)

Notice that both AND and OR take two operands, while NOT takes only one. Also notice that NOT returns true when you give it something false, and false when you give it something true. It can be helpful to think of NOT as something that just flips whatever value you get it. And yes, flipping something twice does return it to its first state. Try these in your REPL:

(not true)
(not (not true))
(not false)
(not (not false))
(not (not (not (not (not true)))))

A handy thing to remember: an even number of NOTs returns the original truth value (a truth value is just whether or not something is true or false) while an odd number of NOTs returns the opposite of the original truth value.

To keep all this stuff straight, it helps to use what is called a truth table. A truth table is a table that tells you when an expression is true or false, based on the truth or falsehood of the things inside of that expression. Here are the truth tables for AND, OR, and NOT:

a	|b	|(and a b)
T	|T	|T
T	|F	|F
F	|T	|F
F	|F	|F

To read this table, look at the truth values for the a and b first, and then for the expression (and a b). Notice that (and a b) is true only when both and b are true. Or is a little different:

a	|b	|(or a b)
T	|T	|T
T	|F	|T
F	|T	|T
F	|F	|F

Notice that (or a b) is true when a is true, when b is true, and also when both are true. That last part is something you need to take notice of: the or operator is what we call an "inclusive or", meaning it's true when both of its operands are true. There is an old joke about the inclusive or that runs like this: a logician has a child. Someone asks the logician whether the child is a boy or a girl. The logician replies, "Yes." Later on, the logician drinks a little wine, and then a little beer. Someone asks the logician, "Did you have wine or beer today?" and the logician again replies, "Yes."

Finally, the truth table for not, which is quite simple:

a	|(not a)
1	|0
0	|1

As you can see, whatever you input for a gets flipped around to the other value.

You can mix boolean and comparison operators because comparison operators return boolean values and boolean operators take boolean values (and return them). Try this in your REPL, but be careful to get it exactly right:

(not (or (and (= 1 0) (>= 11 7)) (not= 5 5)))

You'll notice that this returns true. The reason is that the comparison operators in the inmost parentheses are evaluated first:

(not (or (and (= 1 0) (>= 11 7)) (not= 5 5)))		|The original expression
(not (or (and false (>= 11 7)) (not= 5 5)))		|(= 1 0) is false
(not (or (and false true) (not= 5 5)))			|(>= 11 7) is true
(not (or (and false true) false))			|(not= 5 5) is false
(not (or false false))					|(and false true) is false
(not false)						|(or false false) is false
true							|(not false) is true

Now that we've learned a bit about boolean operators, comparison operators, and boolean values, we can proceed to flow control, as promised.

The most basic flow control statement is the if statement, as we noted before. The if statement has the structure, (if <condition> <clause> <else>). If <condition> has the boolean value of true, then <clause> is executed. If not, then <else> is executed. Try the following in your REPL:

(if true (+ 1 1))
(if true (+ 1 1) (+ 1 2))
(if false (+ 1 1) (+ 1 2))

Notice that you don't need an else clause. You just say, "If this, then do this." But, Clojure is flexible enough to let you say, "If this, then do this, but otherwise to this," which is what the <else> clause is about. You can also add other expressions into the if statement. Try this in your REPL:

(def number (atom 5))
(if (= @number 5) (print "Five!") (print "Some other number."))
(swap! atom + 1)
(if (= @number 5) (print "Five!") (print "Some other number."))

In most terminals, pressing the up arrow on your keyboard will allow you to re-enter a previous line. But notice what happens! If you run the test when number holds the value of 5, then the clause is executed, because (= @number 5) evaluates to true. Notice how the flowchart logic works here: (see atomflowchart.png). The condition part of the tree can be anything so long as it finally becomes a boolean value when the program is done evaluating it, and the clauses can be whatever you want as long as it's a set of instructions Clojure can understand.

Another important flow control operator is WHILE. The WHILE operator takes a condition, much like the IF operator. The difference is that the IF operator will only execute once. The WHILE operator, by contrast, will execute over and over until its condition is no longer true. For example, try this in your REPL:

(def a (atom 0))
(while (< @a 10) (do (println @a) (swap! a inc)))

Notice the structure of the while statement: (while <condition> (do (this) (this) (and this))). While <condition> is true, everything in front of the do statement will be executed over and over until the condition is no longer true. In this case, it prints the value of a, and then adds 1 to a, and the condition is that it will do this until a is no longer less than 9. Now, try this in your REPL:

(def a (atom 0))
(while (< @a 10) (do (swap! a inc) (println @a)))

Notice that the output you get for this is a little different now. Can you figure out why?

Now that we have a little bit of flow control under our belt, let's write some programs!

Our first short program will be called Guess Which Number? You'll make it by typing this into your terminal: vim guesswhichnumber.clj

Once it's open, press I in vim to enter insert mode, and type the following:

(def current-number (atom 0))

(while (not= current-number 17)
	(do (let [user-number (read-line)]
		(println "I'm thinking of a number. Can you guess what it is?)
		))
