CHAPTER ONE

To begin with, you'll want to install Clojure. Clojure runs on the JVM, which means we'll be installing Java first. What dependencies Clojure has will depend heavily on what OS you're running. The rest of this chapter will assume that you're running Linux. In particular, we're assuming that you're running some flavor of Ubuntu. A Debian-based or other distro may have slightly different requirements. On a Windows install, you will want to set up a Linux virtual machine to install Clojure on. If you just want to experiment with the REPL without actually writing full-length programs, repl.it has an in-browser Clojure REPL that you can use.
The dependencies for Clojure in this context are bash, curl, rlwrap, and Java itself. the sudo apt-get install command should suffice to install most of these on most Linux distributions. If that doesn't work, try running sudo apt-get update first, and then installing. Any further troubleshooting will depend on what version/distro of Linux you are working with.
Once everything has been installed, you can begin playing with Clojure by typing clj into your terminal. This initiates a REPL for closure. REPL stands for Read, Evaluate, Print, Loop. This is a very fancy way of saying that we have initiated an interactive shell for Clojure. What that means is that we can type in stuff from the Clojure language and see output in real time. We can type in functions, literals, commands, and so on, and watch the interpreter do stuff in real time. It is very similar to Python's interactive shell. The "read" part of REPL is where the interpreter reads our input that we type in at the command line. The Evaluate part of REPL is where the interpreter evaluates that input to produce output for us. The Print part of REPL is where the interpret takes the output and displays it on the command line. REPL: Read, Evaluate, Print, Loop.
Once we have the REPL open, we can mess with Clojure a little in order to see what various commands do and how the interpreter responds to different stuff from the Clojure language. You can begin by typing in some literals, such as 42, 42.0, "String", and so on. You will notice that literals evaluate to themselves, i.e the interpreter prints out whatever literal it was given as input.

The REPL will be our tool early on because it allows us to type in commands and try different things. You will remember these things much better if you actually do them instead of just reading about them. Much as a pianist will remember a scale much better if they sit down and actually play that scale, a software developer who employs the concepts that they are learning will retain those concepts much better than if they merely read about them.

To begin with, we'll start with the arithmetic operations, since these are the easiest and most basic operations. Open up your REPL and type this:

(+ 1 1)

And press enter. If you do so, the program will return,

=> 2.

What happened? Right of the bat, this looks a little different from the math you saw in school. Ordinarily, in your school mathemetics, the plus sign, as well as other OPERATORS such as the division and multiplication signs, went between numbers. But here, those operators go at the beginning, and the whole thing is enclosed in parentheses. What's going on here!?

To begin with, everything in Clojure is a function. Whenever you enclose something in between those two parentheses, you're not just categorizing it the way you do in algebra. Rather, every set of parentheses CALLS a function. That means that those parentheses say to Clojure, "Hey, you! See these parentheses? There's a function inside of here, which is a set of instructions for you to follow. Look inside of these parentheses and execute this function!" Every set of parentheses in Clojure is a function call. Functions in Clojure, as stated, are a set of operations or instructions, and zero or more ARGUMENTS. Think of the instructions and operations as a machine, and think of the arguments as a set of things that you put into one end of that machine. What comes out the other end of the machine is the result of applying those instructions to that argument. So when you type (+ 1 1), you're taking the plus + operation and feeding it two integers, 1 and 1, and having it add those together. The integers are the arguments to the function, and the function itself, in this case, consists of adding the arguments together.

Another difference between the operations you learned in school and the operations in Clojure, besides just the order you write them in, is how many arguments they can take. In school, you wrote addition like this: 1 + 1, and the result like this: = 2.The addition you learned in school is a "binary operation" or an operation that operates on two things, in this case the numbers on the left and right. Clojure addition, however, is not limited in this way. In Clojure, addition can operate on as many things as you want! So you can try typing the following into your REPL:

(+ 2 3)
(+ 3 5 7)
(+ 7 5 3)
(+ 7 11 13 17 19 23)
(+ 31)
(+)

And notice what happens. No matter how many arguments you put in, the addition operator will faithfully gather them all up and add them all together. And this works for all of the arithmetic operators, which are as follows:

+
-
/

These are addition, subtraction, and multiplication. There is no exponentiation symbol in Clojure, although there are, of course, ways to crete an exponentiation function, which we shall learn about later. To see how subtraction pans out, try the following:

(- 10 5)
(- 5 10)
(- 1 2)
(- 2 1)
(- 2 3 5 7 11)
(- 23 19 17)

Finally, we come to our third basic operator in Clojure, which works a little differently than you might think: division. Division in Clojure can be done differently depending on the kind of number you're dealing with. And this, incidentally, is a good place to introduce the two most basic types of numbers in Clojure: ints and doubles. Ints are integers, meaning simple numbers with nothing after the decimal point. Doubles are decimal numbers. Try typing the following:

(type 1)
(type 2)
(type 3)
(type 1.0)
(type 2.0)
(type 3.0)

The type function tells you what type of thing a thing is. The type function only takes one argument.

Now, the reason we've taken this little detour to talk about data types is this: how division works changes based on what kind of number you use. Using division on integers is very different from using division on doubles. Try the following in your REPL:

(/ 2 3)
(/ 4 6)
(/ 8 12)
(/ 6 2)
(/ 6 3)
(/ 2.0 3)
(/ 2 3.0)
(/ 4.0 6)
(/ 6.0 3)

You'll notice something interesting: what result you get back from the division depends on what kind of number you give it. If you give the division operator at least one double, you'll get back a double. So (/ 3.0 2) and (/ 3 2.0) both give you back 1.5. However, if you only give integers to the division operator, you'll get something else back. You'll either get an integer, if the denominator divides evenly into the numerator, or you get what is known as a ratio. The ratio is basically a fraction. It automatically reduces to its simplest form. Since 4/6 reduces to 2/3, running (/ 4 6) will yield the ratio 2/3.

Obviously, if all you could ever do was just feed a few arguments into a function, you would never get much done in Clojure. That's why functions can be composed, or put together, to make new things. Try the following in your REPL:

(* (/ 3 2) 2)
(/ (+ 5 7) 6)
(+ (/ 1 3) (/ 1 3) (/ 1 3))
(- 1 (/ 1 2))

Similarly to the algebra used in school, the inner parentheses are evaluated first, and then the results of those expressions are evaluated within the larger parentheses. Composing functions in this way is the brass tacks of how we build big things in Clojure.

There's one last data type you need to know about, and that is the string. A string is a sequence of characters. When we're scraping websites later on, string manipulation will be important, because a lot of the data that we download from websites will be in text form, which means it will be stored in strings. Try the following in your REPL:

"put"
(str "put " "it")
(str "put " "it " "all " "together!")
(str "with numbers, too, such as " 1 "!")

You'll notice that entering a string into the REPL returns a string, while using the str function sucks up any argument you put in there and then returns one big string of everything you fed the function.

Finally, variables. Think of a variable as an envelope, and of the value of that variable as the contents of the envelope. Variables store values. An envelope can hold a five dollar bill, or a ten dollar bill, but it is not, itself, a dollar bill. It can also change, where you take out the five dollar bill and put in a ten, or vice versa. You can even leave it empty! Variables are much more important in other programming languages, such as Java and Python, because many popular languages are "object oriented." This means that other languages have this notion of a 'stateful' object, or an object with states that can change. For example, in other languages, you might have a class that has a lot of different attributes that can all change. In Clojure, there is only one type of variable that you should use, and that is the atom. We define an atom using the def keyword, thus:

(def five-dollar-bill (atom 5))

Type those two, and then try the following in your REPL:

five-dollar-bill

@five-dollar-bill

(+ five-dollar-bill five-dollar-bill)

(+ @five-dollar-bill 5)

Notice what you get in each case? five-dollar-bill, by itself, refers to the container, the variable, while @five-dollar-bill refers to the variable, the thing inside of the envelope. Let's make another one. Try the following commands, one at a time.

(def dollar-bill (atom 1))

@dollar-bill

(swap! dollar-bill + 10)

The swap! function changes what's in the envelope for something else. In this case, it lets you add ten to whatever's in the envelope, which is like putting more money in there. You can also take money out:

(swap! dollar-bill - 10)

We can also define atoms as strings and add to those strings. Try the following, one at a time:

(def name (atom "Sir"))

(swap! name str " Arthur")

(swap! name str " Conan")

(swap! name str " Doyle")

@name

(reset! name "Edgar Alan Poe")

@name

(reset! name 1003401)

@name

It's always a good idea to use descriptive names in programming. You'll notice that the five-dollar-bill atom contained the value 5, while the dollar-bill atom, which changed values a lot, had a more general name. Meanwhile the variable containing strings containing the names of various famous authors was called "name" to reflect that. This is part of "style" or the conventions that software developers use to make sure their code is readable for other software developers.

Now that we've learned the nuts and bolts of Clojure, let's create our first Clojure program! To begin with, type "vim helloworld.clj" into your terminal. This will open a buffer. Press I to enter insert mode, and type the following:

;This program will say hello and then ask for your name
(println "Hello, world!")
(println "What's your name?")
(let [username (read-line)]
(println (str "Pleased to meet you, " username "!")))

Press the esc key, type :wq and then enter. :wq stands for "write quit," which will save (write) your file and then quit the program. Now that you're back to your normal terminal, try this:

clj helloworld.clj

And watch the magic! The program will print "Hello, world!" and ask for your name. Type your name, and it will greet you by name. Et voila! The program executes top to bottom and then returns to terminal when it's done.

Let's dissect this program and see what's going on under the hood.

First of all, we have this line:

;This program will say hello and then ask for your name

This is a COMMENT, which is just a note to anyone reading your source code telling them what the source code does. Then we have the following:

(println "Hello, world!")
(println "What's your name?")

This is the println function, which prints a line of text to the terminal and then enters a line break, so that whatever prints next is on a new line. The println function, in this case, takes a string as an argument and prints it out. The line break is there to make sure that whatever prints next doesn't print on the same line, which is why "Hello, world!" and "What's your name?" print on two separate lines. Next up is:

(let [username (read-line)]
(println (str "Pleased to meet you, " username "!")))

The 'let' keyword defines what is known as a symbol. This isn't one hundred percent accurate, but for right now, it's okay to think of a symbol as a variable that never changes. In reality, there is a more subtle difference than that, but for now, it's okay to think of it as an immutable variable, even if that's not QUITE what it is. The let keywork here works like this:

(let [symbol (thing)]

which means that we're saying, "Let this symbol stand for this thing." In this case, the thing in question is the read-line function, which tells the program to pause and wait for the user to type something and press enter. So whatever the user types, is what the username symbol stands for. Finally, we have

(println (str "Pleased to meet you, " username "!")))

You will remember that the str function takes all the stuff you give it and sticks it into one long string. But the word, username, is not in quotes. If it were inside of quotes then the println function would print out, "Pleased to meet you, username!" because it would think that username was just the insite of the string. But it's not, so it gets EVALUATED and the program looks past the symbol and grabs whatever the symbol stands for. So if the user types in "Bob" for their name, the program will say "Pleased to meet you, Bob!" instead of "Pleased to meet you, username!" because it understands that username is just a symbol for whatever the user typed in and not a literal string.

Before we wrap up this chapter, we have a few more functions to learn. The first one is count. You can use it to find the length of a string. Try this in your REPL:

(count "Artichoke")

And it will give you

=> 9

Now try these in your REPL, one at a time:

(count "")
(count "Psych! I'm actually a star-spider.")
(count "Eenie Meenie Miney Moe")

And see what you get back.

Finally, let's learn about casting, or, as it's known in Clojure, coercing. Coercing is a way of turning one data type into another. Try the following in your REPL, one at a time:

(type 9)
(str 9)
(type (str 9))
(type "9")
(int "9")
(type (Integer/parseInt "9"))

Notice how that works? The str function can take the long 9 and turn it into a string, and the type keyword tells you what's going on there. The type of 9 is long, but the type of (str 9) is a string. The type of "9" is a string, and (str 9) returns "9" and is thus equivalent to it. Ditto for (Integer/parseInt "9"). This is called coercing, and it will become important later when we have big text files and we're hunting through them for numerical data to feed into our functions. On the other hand, if we want to put a number into a string and write that into a text file, coercing the number into a string may turn out to be useful.

Now, let's finish up by adding a few more lines to our program:

;This program will say hello and then ask for your name
(println "Hello, world!")
(println "What's your name?")
(let [username (read-line)]
(println (str "Pleased to meet you, " username "!"))
(println (str "Your name is " (count username) " letters long.")))
(println "How many years old are you? Type a number.")
(let [userage (read-line)]
(println (str "You are " userage " years old, and you will be " (+ (Integer/parseInt userage) 1) " in a year.")))

Notice how the last few lines do not do anything new, but uses what we've already learned to expand on the original concept a little. Now it tells the user how old they are, and how old they will be in one year. Note how Integer/parseInt is used to coerce the string into becoming an integer so we can add 1 to it, and also notice how the str function near the beginning of the final line turns it all back into one big string.

SUMMARY
So far, we've learned how to do basic arithmetic in Clojure, how to cast different data types as one another, what are data types exactly, how to get user input, what are variables and atoms, and how to use a REPL. In the next chapter, we'll go a step further and learn flow control. Flow control will take much of what we're doing and put it together into a larger structure.

CHAPTER TWO - FLOW CONTROL

The program we wrote last chapter executed from beginning to end, top to bottom, like a grocery list, just going down the page and executing the instructions one at a time. Very few real-life programs work like this, though. In real programs, the computer makes decisions: it can execute a single instruction multiple times, skip some instructions, or choose which instructions to run. The means of doing this is called flow control, and it works in a manner very similar to a flowchart. Observe this diagram (see: flowchart.png).

This is an instance of flow control using what are known as if-else statements. First, we start with a situation where the computer does not work. IF it is not plugged in, THEN we plug it in. ELSE, we go to the next step and ask if the computer is turned on. IF it is turned on THEN we restart it. ELSE, we turn it on. This is an instance of flow control. In order to make a computer program that works like a flowchart, you need to have a way to represent truth and falsity, yes and no; "Is the computer turned on?" is answered with yes or no because it is either true or false that the computer is turned on. In this case, we are using what is known as boolean values.

A boolean operation turns on whether or not a value is true or false. Fire up your REPL and try the following:

(= 1 1)
(= 1 2)
(true? (= 1 1))
(true? (= 1 2))
(false? (= 1 1))
(false? (= 1 2))

You'll notice that (= 1 1) returns true and (= 1 2) returns false because 1 does not equal 2. (true? <statement>) returns true if <statement> is true, and (false? <statement>) returns true if <statement> is false. Clojure can return boolean values in many other ways as well, using these comparison operators:

=	|equals
not=	|does not equal
<	|less than
>	|greater than
<=	|less than or equal to
>=	|greater than or equal to

These are comparison operators that return boolean values when they compare two things. Try the following commands in your REPL, one at a time:

(not= 1 1)
(not= 1 2)
(< 2 3)
(< 5 3)
(> 5 7)
(> 7 5)
(<= 7 11)
(<= 11 7)
(<= 11 11)
(>= 7 11)
(>= 11 7)
(>= 13 13)
(= 17 17)
(= 17 19)
(= 19 17)

This should give you a good gut feeling for how these comparison operators work, but we're not quite done yet. You might have guessed by now that these comparison operators work differently depending on what data types you give them. A string is never equal to a number, for example. To verify this, try the following in your REPL, one at a time:

(= 0 "0")
(= "0" "0")
(= "0" "Clojure")
(= "Clojure" "Clojure")
(= "Clojure" "clojure")
(= 0.0 0.0)
(= 0 0.0)

However, even though different data types are never equal, some operators can, in fact, take operands of different types (an operand is just the thing an operator takes, e.g. a and b are the operands for a + b and the operator is +). For example inequality operators can take operands of multiple types. Try these in your REPL:

(<= 2 2.0)
(< 2 99.321)
(> 2 500)
(> 2.1 0)

In addition to comparison operators, there are also boolean operators, or operators that return a boolean value and take boolean values. The three boolean operators are AND, OR, and NOT. Try the following in your REPL:

(and true true)
(and false false)
(and true false)
(or true true)
(or true false)
(or false false)
(not true)
(not false)

Notice that both AND and OR take two operands, while NOT takes only one. Also notice that NOT returns true when you give it something false, and false when you give it something true. It can be helpful to think of NOT as something that just flips whatever value you get it. And yes, flipping something twice does return it to its first state. Try these in your REPL:

(not true)
(not (not true))
(not false)
(not (not false))
(not (not (not (not (not true)))))

A handy thing to remember: an even number of NOTs returns the original truth value (a truth value is just whether or not something is true or false) while an odd number of NOTs returns the opposite of the original truth value.

To keep all this stuff straight, it helps to use what is called a truth table. A truth table is a table that tells you when an expression is true or false, based on the truth or falsehood of the things inside of that expression. Here are the truth tables for AND, OR, and NOT:

a	|b	|(and a b)
T	|T	|T
T	|F	|F
F	|T	|F
F	|F	|F

To read this table, look at the truth values for the a and b first, and then for the expression (and a b). Notice that (and a b) is true only when both and b are true. Or is a little different:

a	|b	|(or a b)
T	|T	|T
T	|F	|T
F	|T	|T
F	|F	|F

Notice that (or a b) is true when a is true, when b is true, and also when both are true. That last part is something you need to take notice of: the or operator is what we call an "inclusive or", meaning it's true when both of its operands are true. There is an old joke about the inclusive or that runs like this: a logician has a child. Someone asks the logician whether the child is a boy or a girl. The logician replies, "Yes." Later on, the logician drinks a little wine, and then a little beer. Someone asks the logician, "Did you have wine or beer today?" and the logician again replies, "Yes."

Finally, the truth table for not, which is quite simple:

a	|(not a)
1	|0
0	|1

As you can see, whatever you input for a gets flipped around to the other value.

You can mix boolean and comparison operators because comparison operators return boolean values and boolean operators take boolean values (and return them). Try this in your REPL, but be careful to get it exactly right:

(not (or (and (= 1 0) (>= 11 7)) (not= 5 5)))

You'll notice that this returns true. The reason is that the comparison operators in the inmost parentheses are evaluated first:

(not (or (and (= 1 0) (>= 11 7)) (not= 5 5)))		|The original expression
(not (or (and false (>= 11 7)) (not= 5 5)))		|(= 1 0) is false
(not (or (and false true) (not= 5 5)))			|(>= 11 7) is true
(not (or (and false true) false))			|(not= 5 5) is false
(not (or false false))					|(and false true) is false
(not false)						|(or false false) is false
true							|(not false) is true

Now that we've learned a bit about boolean operators, comparison operators, and boolean values, we can proceed to flow control, as promised.

The most basic flow control statement is the if statement, as we noted before. The if statement has the structure, (if <condition> <clause> <else>). If <condition> has the boolean value of true, then <clause> is executed. If not, then <else> is executed. Try the following in your REPL:

(if true (+ 1 1))
(if true (+ 1 1) (+ 1 2))
(if false (+ 1 1) (+ 1 2))

Notice that you don't need an else clause. You just say, "If this, then do this." But, Clojure is flexible enough to let you say, "If this, then do this, but otherwise to this," which is what the <else> clause is about. You can also add other expressions into the if statement. Try this in your REPL:

(def number (atom 5))
(if (= @number 5) (print "Five!") (print "Some other number."))
(swap! atom + 1)
(if (= @number 5) (print "Five!") (print "Some other number."))

In most terminals, pressing the up arrow on your keyboard will allow you to re-enter a previous line. But notice what happens! If you run the test when number holds the value of 5, then the clause is executed, because (= @number 5) evaluates to true. Notice how the flowchart logic works here: (see atomflowchart.png). The condition part of the tree can be anything so long as it finally becomes a boolean value when the program is done evaluating it, and the clauses can be whatever you want as long as it's a set of instructions Clojure can understand.

Another important flow control operator is WHILE. The WHILE operator takes a condition, much like the IF operator. The difference is that the IF operator will only execute once. The WHILE operator, by contrast, will execute over and over until its condition is no longer true. For example, try this in your REPL:

(def a (atom 0))
(while (< @a 10) (do (println @a) (swap! a inc)))

Notice the structure of the while statement: (while <condition> (do (this) (this) (and this))). While <condition> is true, everything in front of the do statement will be executed over and over until the condition is no longer true. In this case, it prints the value of a, and then adds 1 to a, and the condition is that it will do this until a is no longer less than 9. Now, try this in your REPL:

(def a (atom 0))
(while (< @a 10) (do (swap! a inc) (println @a)))

Notice that the output you get for this is a little different now. Can you figure out why?

SUMMARY: in this chapter, we learned about flow control, boolean statements, and boolean values. In the next chapter, we will put together our flow control and boolean values in order to create functions, which will enable us to write real programs.

CHAPTER 3 - FUNCTIONS

A function is like a miniature program-inside-a-program. The point of a function, fundamentally, is to create a block of code that you can execute at will by CALLING it. Think of a function as a little machine that does a task over and over. Try writing this in your REPL:

(defn my-function [] (+ 1 1))

You have now defined a new function called my-function. Now try this:

(my-function)

Every time you type this, the REPL will print 2. So, what's going on here? Well, the defn keyword stands for "DEfine FuNction" and is there to let Clojure know that you want to make a new function. So the structure of the statement is like this:

(defn <name-of-function> [<parameters>] <code>)

As you can probably tell, name-of-function is whatever the function is going to be named. By typing that name in parentheses, you can call that function. <parameters> are sort of like slots in the function for the arguments you want to pass to it, and <code> is whatever you want the function to do with those parameters. For example, try this in your REPL:

(defn add-and-double [a b] (* 2 (+ a b)))

(add-and-double 19 17)

That second line will return:

=>72

Clojure will add a and b together when it evaluates the innermost pair of parentheses, which it will do first. It will then multiply their sum by 2, and return the result. Putting [a b] into brackets like that tells Clojure that this function will take two arguments, and the arguments will be referred to by the parameters a and b. That means that, when you call the function, you replace the parameters a and b with whatever arguments you want to feed into the function. Take a moment to reflect on the power of that! You can create a block of code - any code you want - and tell it what arguments to take, and what to do with those arguments. We DEFINE a function by labeling it with a name and telling Clojure what it does, and give it PARAMETERS so it knows how many ARGUMENTS to take. We can then PASS arguments to the function according to its defined parameters. The difference between an argument and a parameter is a subtle one, so I'll take a minute to explain it further: a parameter is part of a function, while an argument is something you put into the function. In our function above, a and b are the parameters, or the part of the function definition that tells it how many arguments to take. The arguments are 19 and 17, which are the things we put into the parameters.

Another distinction that is somewhat subtle is the difference between a VARIABLE, a KEYWORD, and a SYMBOL. A variable is like an envelope containing an object, and the object in the envelope can be swapped out or modified. In Clojure, only atoms are variables. A symbol is one thing that stands for another thing: when we write "def n 7" we are defining n as 7. It's important to note that this is NOT a variable, although the syntax with which we declare it is similar to how other languages declare variables. Rather, n is a SYMBOL for 7, and is considered immutable, like all data types in Clojure besides atoms. Once we declare n to be 7, it is 7 for as long as it exists.

When functions are executed, the program is essentially stopping and going to some other line of code, executing that block of code, and then returning to where it was. So if we write:

1. (defn add-five [x] (+ x 5))
2. (def k 3)
3. (print "Let's take a look at this function: ")
4. (add-five k)

and execute it, Clojure reads the whole program top to bottom. When Clojure reaches line 4, it stops and returns to line 1, and executes whatever code it sees there, replacing x with whatever argument was passed in line 4. In this case, we passed the symbol k, which is evaluated to 5, and then passed as an argument to the function defined on line 1. You can think of functions, in a sense, as an instruction for the program to stop and backtrack to where it was previously, and execute whatever code is defined under the name of that function.

This brings us to another critical discussion that we need to have in order to really understand Clojure, which is the discussion of scope. Scope is a concept that you'll run across in pretty much any modern programming language, although different languages have different ways of dealing with it. Scope basically tells you where a name is valid. Consider the following bit of code, which you can write into a .clj file and run to see its output:

1	(def z 2)			|Create the symbol z and associate it with 2.
2	(defn add-3-to-z [] (+ z 3))	|Create a function that returns z + 3, so 5
3					|
4	(let [z 5]			|Let z equal 5.
5	(print (+ z 3)			|Print z + 5
6	(add-3-to-z)))			|Call add-3-to-z

You'll notice something a bit strange: line 5 prints out 8, while line 6 prints out 5. So the z in line 5 is equal to 5, while the function call in line 6 references the z defined on line 1. In fact, the z defined on line 1, and the z defined on line 6, are two different symbols! What's going on here? How come the definition on line 4 doesn't overwrite the definition on line 1? Shouldn't the value of z change after line 4? And how come line 6 still knows what the definition of z on line 1 was? How in the world does all this work!?

The answer is scope. The z defined on line 1 is a GLOBAL symbol, meaning it's valid everywhere in the program, unless it is SHADOWED by something else. In the case of line 4, z is temporarily shadowed when we write let [z 5].Inside of those parentheses where let occurs, z = 5. When we call the function on line 6, however, the program backtracks to line 2. THAT z refers to the definition in line 1, because the function is defined outside of the let block.

It's okay to be confused by that last paragraph. Scope can be a little hard to understand. Another way to think about it is this: think of a let block as a room. Inside of that room, z is defined as 5, so whenever you say "z" inside of the let room, it means five. But after you step outside of that room, z stops meaning five and goes back to meaning 2. The function is sort of like a little machine: when you call the function, it leaves the room, finds a z that means 2, and then comes back into the room and returns the result.

Finally, it's time to talk about EXCEPTION HANDLING. One of the realities of software engineering is that things go wrong; programs have bugs, developers make mistakes, users input things they should not, programs crash, hardware doesn't always work the way it's supposed to, and so on. Exception handling is one way that we can deal with this as developers. Exception handling is a neat feature of many programming languages that allows us to build contingency plans into the program itself. The idea is that, instead of just straight-up executing a piece of code, we can instead TRY to execute a piece of code and, if that results in an error, default to something else. Here's an example of how we can use exception handling in Clojure. First, type this in your REPL:

(defn divide-3-by [x] (/ 3 x))

Once you've defined that function and then pressed enter, go ahead and try the following:

(divide-3-by 5)
(divide-3-by 2)
(divide-3-by 0)

You'll notice that that last one throws an error, because you're performing a mathematical operation that is undefined. The question now arises, how can we anticipate this from the user? We, of course, as impeccably wise and learned software developers, know well enough that you cannot divide by zero. But what if someone, a user of our program, makes an input to this function that doesn't work? How can we get around that? The answer is exception handling. Type into your terminal vim exceptions.clj, and write the following code:

(defn john-wayne-division [x]
  (try
    (/ 3 x)
    (catch Exception e "Looks like you tried some division you ain't supposed to, partner!")))

(john-wayne-division 3)
(john-wayne-division 1)
(john-wayne-division 0)
(john-wayne-division 7)
(john-wayne-division "Wild west division!")
(john-wayne-division nil)

Hit escape, then type :wq and press enter to write to the file and quit vim. Now, in your shell, type clj exceptions.clj and press enter. You'll notice that, whenever you try to divide by 0, or do something even more goofy like trying to divide by a string or the nil value, the exception handling activates and John Wayne advises you not to try that again. As fun as that example was, it also helps to try something a little more normal:

(defn normal-division [x]
  (try
      (/ 3 x)
          (catch Exception e (str "got exception: " (.getMessage e)))))

This example showcases why we give the exception a name in the first place. The exception is named e, which means that it's a symbol representing the exception created when we do something stupid like dividing by 0. In this case, Clojure will print out a message from the exception telling us what went wrong, such as trying to cast a string to a number or attempting to divide by zero.

##WILL NEED COLLATZ EXERCISE HERE

CHAPTER 4 - LISTS, VECTORS, AND THEIR METHODS

Most modern programming languages implement some variety of COLLECTION, meaning a data structure that can hold a list or collection of things. For example, Java has lists, maps, and arraylists; C++ has arrays; Python has lists and dictionaries. Clojure implements java.util.collections, meaning it is built on the library of collections available to the JVM. In layman's terms, anything you can do with collections in Java can also be done in Clojure.

The most commonly-used collection type in Clojure is the VECTOR. When you see lots of values inside of a set of brackets, like this: [1 2 3 4 5], you know that you're dealing with a vector. Clojure also uses LISTS, but lists in Clojure are generally used when you want to process something from back to front. Generally speaking, it's advisable to use vectors instead. The reason that you use lists to process things back to front is that lists expand by being PREPENDED, while vectors expand by being APPENDED. To prepend means to add to the beginning, while to append means to add from the end. To see how this works, run the following two commands in your REPL, one at a time:

(conj (list 2 3 5) 7)

(conj [2 3 5] 7)

You will notice that, for the first command, the 7 is added to the beginning, while for the second command, the 7 is added at the end. In the first case, the 7 is PREPENDED, meaning it has been added to the beginning of the list. In the second case, the 7 has been APPENDED, meaning it has been added to the end of the list. So for any application where we need to process things back-to-front, or build something backwards, lists can come in handy. Otherwise, vectors are, generally speaking, the better choice.

Before we go any further and learn to really work with vectors and lists, it is important for you to understand the idea of a method. A method, in object-oriented programming, is a function (more broadly, a procedure) bound to a class. Clojure is not object-oriented, but it does have methods in the sense that it has functions defined on classes of things. For example, there are certain methods that only work on certain data structures. In other languages, such as Python, you can have methods that work only on strings, e.g. string.Lower() which changes the whole string to lower case and only works on strings. In Clojure, we call methods the same way we call any other function, but our methods only work if we give them the right kind of argument.

One of the more fundamental methods that works on vectors is the nth method, which we can call thus: (nth <vector> <number>). Try the following in your REPL, one at a time:

(nth [1 2 3 4 5] 0)
(nth [1 2 3 4 5] 1)
(nth [1 2 3 4 5] 2)
(nth [1 2 3 4 5] 3)
(nth [1 2 3 4 5] 4)
(nth [1 2 3 4 5] 5)

You'll notice that the final one gives you an index out of bound exception, which is a fancy way of saying that the vector has no value with index 5. This is because vector (and list) indices count from 0, so 0 yields the first element while 4 will yield the fifth element. It's useful to keep this in mind when we're slicing vectors, which we'll learn about next.

Vectors can be operated upon to return subvectors, or slices of the original vector. For example, try the following in your REPL, one at a time:

(subvec [1 2 3 4 5 6 7] 0)
(subvec [1 2 3 4 5 6 7] 1)
(subvec [1 2 3 4 5 6 7] 2)
(subvec [1 2 3 4 5 6 7] 3)
(subvec [1 2 3 4 5 6 7] 4)

You'll notice that each function has this form: (subvec <vector> <n>), and you'll also notice that each time you call the function, you get back a sub-vector beginning with index n and running through until the end of the list, e.g. (subvec [1 2 3] 1) returns [2 3]. The subvec function can take an additional argument to slice the list instead of just cutting off one end, and when you do so, it has the form: (subvec <vector> <m> <m>). This will return every value in the list, beginning with and including n, and up to but NOT including m. To get a feel for this, try the following in your REPL, one at a time:

(subvec [2 3 5 7 11 13 17 19 23] 0 3)
(subvec [2 3 5 7 11 13 17 19 23] 1 3)
(subvec [2 3 5 7 11 13 17 19 23] 2 3)
(subvec [2 3 5 7 11 13 17 19 23] 5)
(subvec [2 3 5 7 11 13 17 19 23] 3 7)

You can find the length of a vector using the count function, which you call like this: (count <vec>). This returns the number of items in a vector counting at one. Be careful: if you try to make the m in the previous function equal to the number returned by count, then you'll get an out of bounds error because count counts from one whereas subvec counts from zero. Indices count from zero, but the length of the list is given counting from one. Like this:

Index	 0 1 2 3 4 5 6 7
Vector	[A B C D E F G H]
Count	 1 2 3 4 5 6 7 8

So the subvector of this vector that is 4 units long (i.e. [A B C D]) has a count of 4 but its indices run from 0 to 3.

Another important part of working with vectors is knowing how to change their values at different indices. We accomplish this using the assoc method. Try the following in your REPL, one at a time:

(assoc [1 2 3] 0 "A")
(assoc [1 2 3] 0 "A" 1 "B")
(assoc [1 2 3] 0 "A" 1 "B" 2 "C")

Now, try these two:

(assoc [2 3 5 7 11 13] 1 "B" 4 "Z")
(assoc [1 2 3 4 5] 3 [2.5 3 3.5])

Two things.

First, keep in mind that you never change any vector. Right now, when you type these things into the REPL, it may feel as if you're modifying the vectors, as if you're mutating the state of a persistent object. But, that's not true. What's really happening is that you are taking a vector and passing it as an argument to a function that returns a different vector, similar to the one that you just put in. So when you call (assoc [1 2 3] 0 "A") you're passing the [1 2 3] vector to the assoc function as an argument, and the assoc function is giving you back another vector with a single value replaced with a string. This is not just technical pedantry; immutability is a deep part of how Clojure works and keeping this in mind will make other aspects of the language more intuitive when you learn them later on.

Secondly, you'll notice that the assoc function is clever enough to know which value you feed it is an index, and which one is a thing to put into the vector at that index. The structure of the function is: (assoc <vector> <index 1> <thing 1> <index 2> <thing 2> <index 3> <thing 3> ..... <index n> <thing n>). The point here is that you can input any number of indices (up to the number of indices that the vector has) and get back a new vector with those indices holding the things you associated with them using the assoc function. Incidentally, you might have realized at this point why the "assoc" function has that name.

One last note: the "assoc" method can be used to add new values to a vector, so long as the indices you pass to it come directly after the indices of the original vector. It's okay if you find that description confusing, but the description makes it sound more complicated than it really is. It will be easier if we use some examples.

Suppose you have this vector: ["a" "b" "c"]. The three indices here are 0, 1, and 2. Create that vector in you REPL like so:

(def abc ["a" "b" "c"])

And then run this:

(assoc abc 3 "d")

You'll notice that the output for this function is ["a" "b" "c" "d"]. Clojure looked at the vector, saw that there was nothing in index 3, and placed "d" there per your command. Now, if you type abc again, Clojure will return ["a" "b" "c"] without the "d", showing that the original vector has not changed - remember, data structures in Clojure are immutable! - so the assoc function is really just returning a new vector with an extra value. You can add more than one value this way, thus:

(assoc abc 3 "d" 4 "e")

Which will return ["a" "b" "c" "d" "e"], since the original vector had no indices at 3 or 4 and you filled them.

However, you'll get an error if you try this:

(assoc abc 4 "e")

Because there is no index 3, so Clojure is trying to create a vector with some sort of weird gap in it. Clojure can't do anything like that, so you get an error. If you want to use the assoc function to return a new vector with new values that is longer than the original, then the new indices you define values in must be adjacent to the original values.

If you want to check whether a vector contains a particular value, you may do so using the contains method, which you can call thus: (contains? <vector> <thing>). Try the following in your REPL:

(contains? [1 2 3] 1)
(contains? [1 2 3] "A")

When you call contains? it will, unless you feed it something that throws an error, always return a boolean value that simply tells you whether or not the specified thing is in the vector.

There are times when we want to find the index of a particular item within a vector. In these cases, we use the .indexOf method. Try this in your REPL:

(def new-vector ["a" "b" "c" "d" "e"]
(.indexOf new-vector "b")

If all goes well, this will return 1, since "b" is the second value in new-vector. Now, for a slightly trickier example:

(def new-vector ["a" "b" "a" "c"])
(.indexOf new-vector "a")

You'll notice that this command returns 0 rather than 2, even though "a" is present at two indices in new-vector. This is because the .indexOf method only returns the index of the first occurrence of an item in a vector. Therefore, if you have a vector 100 entries long, and that vector has 21 occurences of the string "ABC", and you run (.indexOf that-vector "ABC"), you'll get the index of the first occurrence of "ABC" in that vector.

You can also sort vectors, and other collections too. To sort a vector or list, just type (sort <collection>). As always, the paremeter passed to the function can be the symbol for a thing or the thing itself. Try the following in your REPL.

(sort [0 9 8 7 6])
(sort (list 2 3 1 4 2 5 3 1))
(sort "the quick brown fox jumps over the lazy dog")

You'll notice something funny about that last sort. Well, two things. First, and less importantly, it contains the entire alphabet plus three spaces. Second, and much more importantly, it returns a sequence of letters and the word "space" with a backslash \ before each one. What does that mean? What that means is that you've got a sequence of "characters," which are their own special data type in Clojure. Characters are exactly what they sound like: single letters (or spaces, or quotation marks, or some such) that have their own data type in Clojure. The sort function, when called on a string, contains a sorted collection of all of that string's characters.

You can reverse Clojure collections, too. This is done using, surprisingly enough, the reverse function. Try these in your REPL:

(reverse [1 2 3 4 5])
(reverse (list 2 3 1 4))
(reverse "Bob's your uncle!")

Notice that that last one returns a sequence of characters as well. To get around this and get a true string reversal, we can learn a little about the apply function, and then return ot the reverse function after a moment. Try the following in your REPL:

(apply + [1 2 3 4 5])
(+ 1 2 3 4 5)
(apply str 2 3 5 7)
(str 2 3 5 7)

So far you may be scratching your head. "What gives?" you say, "This apply function just does the same thing as passing multiple arguments to a function anyway." The thing is, apply has this nice property that it can distribute over the contents of a collection, such as a vector or other sequence. To see the power of this, try the following in your REPL:

(reverse "Bob's your uncle!")
(str (reverse "Bob's your uncle!"))
(apply str (reverse "Bob's your uncle!"))

Notice the difference there? That second command returns the whole sequence turned into a string, complete with parentheses and slashes. The third command, however, looks INTO the sequence, plucks out each term, and then applies the str function to those. This brings us full circle, because it gave us a true string reversal, but we also learned something valuable during the journey: the apply command can look INTO sequences, pull out their contents, and apply functions to them. Running the command (str (reverse "Bob's your uncle!")) is like taking an envelope full of jigsaw puzzle pieces, and framing the whole envelope in a picture frame. By contrast, running (apply str (reverse "Bob's your uncle!")) is like taking the puzzle pieces out, and fitting them together inside of the frame. It's obvious which one was more desirable in this case.

There is another function in Clojure called "reduce" that works similarly to "apply." In most cases, they're the same, but there is a subtle conceptual difference that can have implications for how they are used. When we run

(apply + [1 2 3 4 5])

This is equivalent to

(+ 1 2 3 4 5)

Whereas, when we run

(reduce + [1 2 3 4 5])

This is equivalent to

(+ 5 (+ 4 (+ 3 (+ 1 2))))

As I said, this will end up the same way in most cases. But it is helpful to know what each function is actually doing, in case you run into any errors that can only be solved by drawing a nice distinction.

So we can reverse things and use apply to get stuff out of vectors so we can operate on their terms one at a time. The last thing to learn is how to turn things into vectors. If you want to turn a string into a vector, use the vec function:

(vec "abc")

Which returns [\a \b \c]. But turning that into a list runs into some issues:

(list [\a \b \c])
=> ([\a \b \c])

(list "abc")
=> ("abc")

Darn! It seems that running the list command only takes the whole thing and puts it into a list, instead of breaking it into a list of many characters. If only there were some way to pull all the characters out of the list, or out of the vector, and apply the "list" function to them one at a time!

Oh, right:

(apply list [\a \b \c])
=> (\a \b \c)

(apply list "abc")
=> (\a \b \c)

You can also coerce these things back into being strings. Obviously, you don't just apply the str command, because if you do:

(str [\a \b \c])
=> "[\\a \\b \\c]"

I shouldn't have to say what the solution is at this point. How do you pull each character out of the vector and apply str to it recursively?



